//
//
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the
// "License"); you may not use this file except in compliance with the License. You may
// obtain a copy of the License at http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT
// WARRANTY OF ANY KIND, either express or implied. See the License for the specific
// language governing rights and limitations under the License.
//
// The Original Code is the Liquid Rendering Toolkit.
//
// The Initial Developer of the Original Code is Colin Doncaster. Portions created by
// Colin Doncaster are Copyright (C) 2002. All Rights Reserved.
//
// Contributor(s): Berj Bannayan.
//
//
// The RenderMan (R) Interface Procedures and Protocol are:
// Copyright 1988, 1989, Pixar
// All Rights Reserved
//
//
// RenderMan (R) is a registered trademark of Pixar
//
//  Creation Date:  June 20, 2000
//
//
//  Description:
//      Liquids Surface Shader Interface.
//
//  Input Arguments:
//
//  Returns:
//

global string $liquidShadersLastDirectory = "";


global proc string[] liquidGetShaderList(string $type)
{
	string $out_shaderlist[];
	if($type == "all")
	{
		string $types[] = {"Surface","Light","Displacement","Volume","Ribbox","Container"};
		for($shader_type in $types)
		{
			if(`attributeExists ("liquid"+$shader_type+"Shaders") liquidGlobals`)
			{
				$out_shaderlist = stringArrayCatenate($out_shaderlist, `listConnections ("liquidGlobals.liquid"+$shader_type+"Shaders")`);
			}
		}
	}
	else
	{
		if(`attributeExists ("liquid"+$type+"Shaders") liquidGlobals`)
		{
			$out_shaderlist = `listConnections ("liquidGlobals.liquid"+$type+"Shaders")`;
		}
	}
	return $out_shaderlist;
}

global proc string liquidGetShaderNodeType( string $node )
{
  string $returnValue;
  int $typeId = `getAttr ( $node + ".typeId" ) `;
  string $type = `substring $node 1 10`;
  if( ( $type == "liquidSurf" ) || ( $typeId == 303126790 ) ) {
    $returnValue = "Surface";
  }
  if( ( $type == "liquidDisp" ) || ( $typeId == 303126791 ) ) {
    $returnValue = "Disp";
  }
  if( ( $type == "liquidLigh" ) || ( $typeId == 303126792 ) ) {
    $returnValue = "Light";
  }
  if( ( $type == "liquidVolu" ) || ( $typeId == 303126793 ) ) {
    $returnValue = "Volume";
  }
  if( ( $type == "liquidRibb" ) || ( $typeId == 303126794 ) ) {
    $returnValue = "Ribbox";
  }
  if( ( $type == "liquidCont" ) || ( $typeId == 303126795 ) ) {
    $returnValue = "Container";
  }
  return $returnValue;
}

global proc liquidAssignShaderNode( string $node, string $shaderNode )
{
  string $type = `liquidGetShaderNodeType $shaderNode`;

  if ( !`attributeQuery -node $node -ex ( "liquid" + $type + "ShaderNode" )`) {
    addAttr -ln ( "liquid" + $type + "ShaderNode" ) -at message $node;
  }
  if ( !`attributeQuery -node $shaderNode -ex "assignedObjects"`) {
    addAttr -m -ln "assignedObjects" -at message $shaderNode;
  }
  int $ch = `constructionHistory -q -tgl`;
  if ( !$ch ) constructionHistory -tgl on;
  connectAttr -f ( $shaderNode + ".assignedObjects" ) ( $node + ".liquid" + $type + "ShaderNode" );

  //extra for ribbox
  if($type == "Ribbox") {
    string $transform = liquidGetTransform( $node );
    liquidCreateRIBBoxAttribute();

	  if(`attributeExists liqRIBBox $transform`) {
	  	string $connection = `connectionInfo -sfd ($transform+".liqRIBBox")`;
      if ( size( $connection ) ) disconnectAttr $connection ($transform+".liqRIBBox");
	  }
	  connectAttr -f ( $shaderNode + ".ribbox" ) ( $transform + ".liqRIBBox" );
  }
  constructionHistory -tgl $ch;
}

global proc string liquidNewRibboxNode( string $nodename )
{
	if($nodename == "")
	{
		$nodename = "ribbox";
	}
	string $shadername = $nodename;
	string $shaderType = "ribbox";
	string $newNodeName = "" ;
	$newNodeName = $shadername;
	if ( `objExists( $newNodeName )` )
	{
		string $testNodeName = $newNodeName;
		for( $i = 1;; $i++ )
		{
			string $cNum = $i;
			$testNodeName = ( $newNodeName + $cNum );
			string $testList[] = `ls $testNodeName`;
			if ( !`objExists( $testNodeName )` ) break;
		}
		$newNodeName = $testNodeName;
	}
	createNode "oldBlindDataBase" -n $newNodeName;
	setAttr ( $newNodeName + ".typeId" ) 303126794;
	addAttr -ln "rmanShaderLong" -dt "string" $newNodeName;
	addAttr -ln "rmanShader" -dt "string" $newNodeName;
	addAttr -ln "liquidShaderManager" -at message $newNodeName;
	setAttr ( $newNodeName + ".rmanShader" ) -type "string" $newNodeName;
	setAttr ( $newNodeName + ".rmanShaderLong" ) -type "string" $shaderType;
	addAttr -ln "ribbox" -dt "string" $newNodeName;

	string $returnValue = $newNodeName;

	if ( !`attributeExists "liquidRibboxShaders" "liquidGlobals"`)
	{
		addAttr -ln "liquidRibboxShaders" -at message liquidGlobals;
	}
    	connectAttr -f "liquidGlobals.liquidRibboxShaders" ( $newNodeName + ".liquidShaderManager" );
	evalDeferred("liquidFluidUpdateList");
	return $returnValue;
}

global proc string liquidNewShaderNode( string $filename )
{
  // Get the shortest usable project path.
  int $i;
  string $returnValue = "";

  string $shortName = basenameEx( $filename );
  string $longName = $filename;

  // parse the shader
  liquidSlInfoReset();
  liquidSlSetShader( $filename );

  // get the correct name for the shader
  // get the correct shader type - possibilities are surface, light, displacement and volume
  string $shaderType = liquidSlShaderType();

  // work out the new shader nodes name an
  string $newNodeName = "" ;
  $newNodeName = $shortName;
  if ( `objExists( $newNodeName )` ) {
    string $testNodeName = $newNodeName;
    for( $i = 1;; $i++ ) {
      string $cNum = $i;
      $testNodeName = ( $newNodeName + $cNum );
      string $testList[] = `ls $testNodeName`;
      if ( !`objExists( $testNodeName )` ) break;
    }
    $newNodeName = $testNodeName;
  }

  createNode "oldBlindDataBase" -n $newNodeName;
  if ( $shaderType == "surface" ) {
    setAttr ( $newNodeName + ".typeId" ) 303126790;
  } else if ( $shaderType == "displacement" ) {
    setAttr ( $newNodeName + ".typeId" ) 303126791;
  } else if ( $shaderType == "light" ) {
    setAttr ( $newNodeName + ".typeId" ) 303126792;
  } else if ( $shaderType == "volume" ) {
    setAttr ( $newNodeName + ".typeId" ) 303126793;
  } else {
    delete $newNodeName;
    error "Unrecognized Shader Type";
  }

  addAttr -ln "rmanShaderLong" -dt "string" $newNodeName;
  addAttr -ln "rmanShader" -dt "string" $newNodeName;
  addAttr -ln "liquidShaderManager" -at message $newNodeName;
  setAttr ( $newNodeName + ".rmanShader" ) -type "string" $shortName;
  setAttr ( $newNodeName + ".rmanShaderLong" ) -type "string" $filename;

  liquidAttachParams $newNodeName;

  $returnValue = $newNodeName;

  // attach the new shader node to liquid globals so liquid can keep track of it.
  if ( !`liquidGlobalsExists` ) {
    liquidCreateGlobals;
  }
  if ( $shaderType == "surface" ) {
    if ( !`attributeQuery -node "liquidGlobals" -ex "liquidSurfaceShaders"`) {
      addAttr -ln "liquidSurfaceShaders" -at message liquidGlobals;
    }
    connectAttr -f "liquidGlobals.liquidSurfaceShaders" ( $newNodeName + ".liquidShaderManager" );
  }
  if ( $shaderType == "displacement" ) {
    if ( !`attributeQuery -node "liquidGlobals" -ex "liquidDisplacementShaders"`) {
      addAttr -ln "liquidDisplacementShaders" -at message liquidGlobals;
    }
    connectAttr -f "liquidGlobals.liquidDisplacementShaders" ( $newNodeName + ".liquidShaderManager" );
  }
  if ( $shaderType == "light" ) {
    if ( !`attributeQuery -node "liquidGlobals" -ex "liquidLightShaders"`) {
      addAttr -ln "liquidLightShaders" -at message liquidGlobals;
    }
    connectAttr -f "liquidGlobals.liquidLightShaders" ( $newNodeName + ".liquidShaderManager" );
  }
  if ( $shaderType == "volume" ) {
    if ( !`attributeQuery -node "liquidGlobals" -ex "liquidVolumeShaders"`) {
      addAttr -ln "liquidVolumeShaders" -at message liquidGlobals;
    }
    connectAttr -f "liquidGlobals.liquidVolumeShaders" ( $newNodeName + ".liquidShaderManager" );
  }
  return $returnValue;
}

global proc string liquidDuplicateShaderNode( string $nodename )
{
  string $shaderFileName = `getAttr ( $nodename + ".rmanShaderLong" )`;

  string $nodeType = `liquidGetShaderNodeType $nodename`;
  string $currentNodeName;
  if($nodeType == "Ribbox")
  {
  	$currentNodeName = `liquidNewRibboxNode $shaderFileName`;
    setAttr -type "string" ($currentNodeName+".ribbox") (`getAttr ($nodename+".ribbox")`);
  }
  else
  {
  	$currentNodeName = `liquidNewShaderNode $shaderFileName`;
  }

  string $newNodeName = ( $nodename + "Duplicate" );
  if ( `objExists( $newNodeName )` ) {
    string $testNodeName = $newNodeName;
    for( $i = 1;; $i++ ) {
      string $cNum = $i;
      $testNodeName = ( $newNodeName + $cNum );
      string $testList[] = `ls $testNodeName`;
      if ( !`objExists( $testNodeName )` ) break;
    }
    $newNodeName = $testNodeName;
  }

  $currentNodeName = `rename $currentNodeName $newNodeName`;

  if ( $nodeType == "Surface" ) {
    if (`attributeQuery -n $currentNodeName -ex ( "color" ) `) {
      float $redValue = `getAttr ( $nodename + ".red" )`;
      float $blueValue = `getAttr ( $nodename + ".blue" )`;
      float $greenValue = `getAttr ( $nodename + ".green" )`;
      setAttr ( $currentNodeName + ".color" ) -type float3 $redValue $greenValue $blueValue;
    }
    if (`attributeQuery -n $currentNodeName -ex ( "opacity" ) `) {
      float $redValue = `getAttr ( $nodename + ".redO" )`;
      float $blueValue = `getAttr ( $nodename + ".blueO" )`;
      float $greenValue = `getAttr ( $nodename + ".greenO" )`;
      setAttr ( $currentNodeName + ".opacity" ) -type float3 $redValue $greenValue $blueValue;
    }
  }

  if ( $nodeType == "Light" ) {
    if (`attributeQuery -n $currentNodeName -ex ( "shadowCamera" ) `) {
      string $shadowCamValue = `getAttr ( $nodename + ".shadowCamera" )`;
      setAttr ( $currentNodeName + ".shadowCamera" ) -type "string" $shadowCamValue;
    }
    if (`attributeQuery -n $currentNodeName -ex ( "deepShadows" ) `) {
      int $deepShadowsValue = `getAttr ( $nodename + ".deepShadows" )`;
      setAttr ( $currentNodeName + ".deepShadows" ) $deepShadowsValue;
    }
    if (`attributeQuery -n $currentNodeName -ex ( "pixelSamples" ) `) {
      int $pixelSamplesValue = `getAttr ( $nodename + ".pixelSamples" )`;
      setAttr ( $currentNodeName + ".pixelSamples" ) $pixelSamplesValue;
    }
    if (`attributeQuery -n $currentNodeName -ex ( "volumeInterpretation" ) `) {
      int $volumeInterpretation = `getAttr ( $nodename + ".volumeInterpretation" )`;
      setAttr ( $currentNodeName + ".volumeInterpretation" ) $volumeInterpretation;
    }
  }

  if ( $nodeType == "Disp" || $nodeType == "Surface" ) {
    if (`attributeQuery -n $currentNodeName -ex ( "displacementBound" ) `) {
      float $displaceValue = `getAttr ( $nodename + ".displacementBound" )`;
      setAttr ( $currentNodeName + ".displacementBound" ) $displaceValue;
    }
  }

  liquidAttachShaderParams( $currentNodeName, $shaderFileName );

  return $currentNodeName;
}

