//
//
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the
// "License"); you may not use this file except in compliance with the License. You may
// obtain a copy of the License at http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT
// WARRANTY OF ANY KIND, either express or implied. See the License for the specific
// language governing rights and limitations under the License.
//
// The Original Code is the Liquid Rendering Toolkit.
//
// The Initial Developer of the Original Code is Colin Doncaster. Portions created by
// Colin Doncaster are Copyright (C) 2002. All Rights Reserved.
//
// Contributor(s): Philippe Leprince.
//
//
// The RenderMan (R) Interface Procedures and Protocol are:
// Copyright 1988, 1989, Pixar
// All Rights Reserved
//
//
// RenderMan (R) is a registered trademark of Pixar
//
//  Creation Date:  June 20, 2000
//
//
//  Description:
//      Liquids Shader Nodes procedures.
//
//  Input Arguments:
//
//  Returns:
//


global string $gLiquidAELastShader;
global string $gLiquidAELastNode;


proc setLastAEShader( string $shader, string $type )
{
  global string $gLastShader_liquidLight;
  global string $gLastShader_liquidSurface;
  global string $gLastShader_liquidDisplacement;
  global string $gLastShader_liquidVolume;
  eval ("$gLastShader_"+$type+" = \""+$shader+"\"");
}

proc string getLastAEShader( string $type )
{
  global string $gLastShader_liquidLight;
  global string $gLastShader_liquidSurface;
  global string $gLastShader_liquidDisplacement;
  global string $gLastShader_liquidVolume;
  return eval ( "$gLastShader_"+$type+" = $gLastShader_"+$type+";" );
}

proc setLastAENode( string $node, string $type )
{
  global string $gLastNode_liquidLight;
  global string $gLastNode_liquidSurface;
  global string $gLastNode_liquidDisplacement;
  global string $gLastNode_liquidVolume;
  eval ("$gLastNode_"+$type+" = \""+$node+"\"");
}

proc string getLastAENode( string $type )
{
  global string $gLastNode_liquidLight;
  global string $gLastNode_liquidSurface;
  global string $gLastNode_liquidDisplacement;
  global string $gLastNode_liquidVolume;
  return eval ( "$gLastNode_"+$type+" = $gLastNode_"+$type+";" );
}


proc rmanParams_create( string $node, int $reReadShaderParams )
{
  if ( $reReadShaderParams ) {
    string $shaderPath = `getAttr ($node+".rmanShaderLong")`;
    liquidSlInfoReset(); // force reload
    liquidSlSetShader( $shaderPath );
  }

  setAttr -type "string" ( $node + ".rmanShader" ) (liquidSlShaderName());

  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanParams " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      $cmd += ( "\"" + liquidSlParamName($i) + "\" " );
  }
  //trace $cmd;
  eval $cmd;

  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanDetails " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      $cmd += ( liquidSlParamDetail($i) + " " );
  }
  //trace $cmd;
  eval $cmd;

  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanTypes " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      $cmd += ( "\"" + liquidSlParamType($i) + "\" " );
  }
  //trace $cmd;
  eval $cmd;

  string $cmd = ( "setAttr -type stringArray " + $node + ".rmanDefaults " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      if ( liquidSlParamType($i) == "string" ) $cmd += ( "\"" + liquidSlParamDefaultRaw($i) + "\" " );
      else $cmd += ( "\"" + liquidSlParamDefaultRaw($i) + "\" " );
  }
  //trace $cmd;
  eval $cmd;

  string $cmd = ( "setAttr -type Int32Array " + $node + ".rmanArraySizes " + liquidSlNumParams() + " " );
  for ( $i = 0; $i < liquidSlNumParams(); $i++ ) {
      $cmd += ( liquidSlParamArraySize($i) + " " );
  }
  //trace $cmd;
  eval $cmd;
}



global proc lifGradient_unifyInterpolation( string $ctl )
{
  global string	$gAEFocusNode;

  string $currentParent = `setParent -q`;
  string $optionMenuCtl = `setParent $ctl`;
  int $selected = `optionMenu -q -sl ($optionMenuCtl+"|optionMenu")` - 1;

  string $attr = substitute("Si$", $ctl, "");
  $attr = substitute("[A-Za-z0-9_]+__", $attr, "");
  string $nodeAttr = ($gAEFocusNode+"."+$attr);
  int $size = `getAttr -s $nodeAttr`;
  for ( $i=0; $i<$size; $i++ ) {
    setAttr ($nodeAttr+"["+$i+"]."+$attr+"_Interp") $selected;
  }
  setParent $currentParent;
}


global proc lifGradient_connect( string $nodeAttr )
{
  string $buffer[];
  tokenize($nodeAttr, ".", $buffer);
  string $attr = $buffer[1];

  string $shader = `getAttr ($buffer[0]+".rmanShaderLong")`;
  $shader = basenameEx( $shader );

  string $rampName = ( $shader + "__" + $attr + "Ramp" );

  gradientControl -e -at $nodeAttr $rampName;

}


global proc lifGradient_create( string $nodeAttr, int $bound, int $indent, int $staticEntries, int $staticPositions, int $adaptiveScaling )
{
  string $buffer[];
  tokenize($nodeAttr, ".", $buffer);
  string $attr = $buffer[1];

  string $topParent = `setParent -q`;

  string $shader = `getAttr ($buffer[0]+".rmanShaderLong")`;
  $shader = basenameEx( $shader );

  string $rampName = ( $shader + "__" + $attr + "Ramp" );
  string $scName   = ( $shader + "__" + $attr + "Scc" );
  string $spName   = ( $shader + "__" + $attr + "Sp" );
  string $siName   = ( $shader + "__" + $attr + "Si" );

  string $colEntryName =  ($nodeAttr + "[0]." + $attr + "_ColorR");
  int $isColor = `objExists ($colEntryName)`;

  setUITemplate -pst attributeEditorTemplate;
  columnLayout -columnAttach "both" 5 -rowSpacing 2 -columnWidth 420;

  // ramp block
  string $rampForm = `formLayout ($rampName + "Form")`;
    string $spc	= `attrFieldSliderGrp -l "Selected Position"
                                      -ann "Selected Position"
                                      -h 30 -w 206 -cw4 123 81 1 1 $spName`;
    string $scc;
    if( $isColor ){
      $scc= `attrColorSliderGrp -l "Selected Color"
                                -ann "Selected Color" -sb 0
                                -h 26 -w 206 -cw4 123 81 1 1 $scName`;
    } else {
      $scc	= `attrFieldSliderGrp -l "Selected Value"
                                  -ann "Selected Value"
                                  -h 30 -w 206 -cw4 123 56 1 24 $scName`;
    }

    string $interp = `attrEnumOptionMenuGrp -l "Interpolation"
                                            -ann "Interpolation method"
                                            -w 206
                                            -cw2 123 81 $siName`;
    string $boundStyle = "etchedIn";
    if( $bound ){
      $boundStyle = "in";
    }
    string $lmax;
    if ( $adaptiveScaling ) {
      $lmax = `text -label "1.0" ($rampName+"LX")`;
    }
    string $rframe = `frameLayout -bs $boundStyle -lv 0 -cll 0 -mw 6 ($rampForm + "fr")`;
    string $widgetName = `gradientControl -at   $nodeAttr
                                          -snc  $staticEntries
                                          -sp   $staticPositions
                                          $rampName`;
    if ( $adaptiveScaling ) {
      gradientControl -e -as $adaptiveScaling -ror $adaptiveScaling -ulc $lmax $widgetName;
    }

    setParent ..;
    formLayout
      -edit
        -attachForm $spc "left"  0
        -attachForm $spc "right" 206
        -attachForm $spc "top" 0
        -attachNone $spc "bottom"

        -attachForm $scc "left" 0
        -attachForm $scc "right" 206
        -attachControl $scc "top" 0 $spc
        -attachNone $scc "bottom"

        -attachForm $interp "left" 0
        -attachNone $interp "right"
        -attachControl $interp "top" 0 $scc
        -attachNone $interp "bottom"

        -attachControl $rframe "left" 2 $spc
        -attachNone $rframe "right"
        -attachForm $rframe "top" 0
        -attachNone $rframe "bottom"
        $rampForm;

    if ( $adaptiveScaling ) {
      formLayout
        -edit
          -attachControl $lmax "left" 2 $rframe
          -attachNone $lmax "right"
          -attachForm $lmax "top" 0
          -attachNone $lmax "bottom"
          $rampForm;
    }
  setParent ..;

  // input
  if(objExists ($nodeAttr +"Input")){
    string $inLabel;
    string $labelAttr = interToUI($attr);
    if( $indent || size( $labelAttr ) < 9 ){
      $inLabel =  ($labelAttr + " Input");
    } else {
      $inLabel = "Input";
    }
    if( $indent ){
      attrEnumOptionMenuGrp -l $inLabel
        -ann "input variable for function"
        -cw2 204 155
        -at ($nodeAttr + "Input") ($rampName + "Input");
    } else {
      attrEnumOptionMenuGrp -l $inLabel
        -ann "input variable for function"
        -cw2 123 500
        -at ($nodeAttr + "Input") ($rampName + "Input");
    }

  }

  // inputBias
  if(  objExists ($nodeAttr +"InputBias") ){
    attrFieldSliderGrp -l "Input Bias" -cw4 123 81 130	25
        -at ($nodeAttr +"InputBias") ($rampName + "InputBias");
  }

  // inputScale
  if(  objExists ($nodeAttr +"InputScale") ){
    attrFieldSliderGrp -l "Input Scale" -cw4 123 81 130 25
        -at ($nodeAttr +"InputScale") ($rampName + "InputScale");
  }
  // tell the port about the controls
  gradientControl -e -scc $scc $widgetName;
  gradientControl -e -spc $spc $widgetName;
  gradientControl -e -sic $interp $widgetName;
  setUITemplate -ppt;

  // add command to unify interpolation
  string $optionMenuCtl = ($interp+"|optionMenu");
  if ( `optionMenu -q -ex $optionMenuCtl` ) optionMenu -e -cc ("lifGradient_unifyInterpolation "+$siName) $optionMenuCtl;

  setParent $topParent;
}


proc lifGradientAttr_connect( string $node, string $valueAttr, string $positionAttr, string $interpAttr )
{
  int $isColor     = ( `getAttr -type ($node+"."+$valueAttr+"[0]")` == "float3" )? 1:0 ;
  int $arraySize   =   `getAttr -size ($node+"."+$valueAttr)`;
  int $multiInterp = ( `getAttr -size ($node+"."+$interpAttr)` )? 1:0;

  string $gradAttr = ($valueAttr+"Lif");

  for ( $i=0; $i<$arraySize; $i++ ) {

    //trace ("  lifGradientAttr_connect "+$node+" "+$valueAttr+"["+$i+"]");

    if ( $isColor ) connectAttr -f ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Color")   ($node+"."+$valueAttr+"["+$i+"]");
    else connectAttr -f ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_FloatValue")   ($node+"."+$valueAttr+"["+$i+"]");

    if ( objExists( ($node+"."+$positionAttr) ) ) {
      setAttr -lock off ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Position");
      connectAttr -f ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Position") ($node+"."+$positionAttr+"["+$i+"]");
    } else setAttr -lock on ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Position");

    if ( objExists( ($node+"."+$interpAttr) ) ) {
      setAttr -lock off ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Interp");
      if ( objExists( ($node+"."+$interpAttr+"["+$i+"]") ) ) {
        connectAttr -f ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Interp")   ($node+"."+$interpAttr+"["+$i+"]");
      } else {
        if ( $i>0 ) continue;
        connectAttr -f ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Interp")   ($node+"."+$interpAttr);
      }
    } else setAttr -lock on ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Interp");
  }
}

proc lifGradientAttr_init( string $node, string $valueAttr, string $positionAttr, string $interpAttr )
{
  int $isColor     = ( `getAttr -type ($node+"."+$valueAttr+"[0]")` == "float3" )? 1:0 ;
  int $arraySize   =   `getAttr -size ($node+"."+$valueAttr)`;
  int $multiInterp = ( `getAttr -size ($node+"."+$interpAttr)` )? 1:0;

  string $gradAttr = ($valueAttr+"Lif");

  for ( $i=0; $i<$arraySize; $i++ ) {

    //trace ("  lifGradientAttr_init "+$node+" "+$valueAttr+"["+$i+"]");

    float $pos    = ( objExists( ($node+"."+$positionAttr+"["+$i+"]") ) )? (`getAttr ($node+"."+$positionAttr+"["+$i+"]")`) : ($i*(1/($arraySize-1)));
    float $interp = 3;
    if ( $interpAttr != "" ) {
      if ( objExists( ($node+"."+$interpAttr+"["+$i+"]") ) )   $interp = `getAttr ($node+"."+$interpAttr+"["+$i+"]")`;
      else $interp = `getAttr ($node+"."+$interpAttr)`;
    }

    setAttr ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Position") $pos;
    if ( $isColor ) {
      float $col[]  = `getAttr ($node+"."+$valueAttr+"["+$i+"]")`;
      setAttr ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_ColorR")   $col[0];
      setAttr ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_ColorG")   $col[1];
      setAttr ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_ColorB")   $col[2];
    } else {
      float $val  = `getAttr ($node+"."+$valueAttr+"["+$i+"]")`;
      setAttr ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_FloatValue")  $val;
    }
    setAttr ($node+"."+$gradAttr+"["+$i+"]."+$gradAttr+"_Interp")   $interp;

  }
}

proc string lifGradientAttr_create( string $node, string $valueAttr, string $positionAttr, string $interpAttr )
{
  int $isColor = ( `getAttr -type ($node+"."+$valueAttr+"[0]")` == "float3" )? 1:0;

  string $gradAttr = ($valueAttr+"Lif");

  if ( !`objExists ($node+"."+$gradAttr)` ) {
    //trace ("lifGradientAttr_create "+$node+" "+$valueAttr+"  >  "+$gradAttr);
    addAttr -hidden true -ln $gradAttr -attributeType compound -numberOfChildren 3 -multi $node;
      addAttr -hidden true -ln ($gradAttr+"_Position") -attributeType "float" -parent $gradAttr $node;
      if ( $isColor ) {
        addAttr -hidden true -ln ($gradAttr+"_Color") -usedAsColor -attributeType float3 -parent $gradAttr $node;
          addAttr -hidden true -ln ($gradAttr+"_ColorR") -attributeType "float" -parent ($gradAttr+"_Color") $node;
          addAttr -hidden true -ln ($gradAttr+"_ColorG") -attributeType "float" -parent ($gradAttr+"_Color") $node;
          addAttr -hidden true -ln ($gradAttr+"_ColorB") -attributeType "float" -parent ($gradAttr+"_Color") $node;
      } else {
        addAttr -hidden true -ln ($gradAttr+"_FloatValue") -attributeType "float" -parent $gradAttr $node;
      }
      addAttr -hidden true -ln ($gradAttr+"_Interp") -attributeType "enum" -en "none:linear:smooth:spline" -parent $gradAttr $node;

    lifGradientAttr_init( $node, $valueAttr, $positionAttr, $interpAttr );
    lifGradientAttr_connect( $node, $valueAttr, $positionAttr, $interpAttr );
  }
  return $gradAttr;
}








/**
 *  initialize shader parameters on shading node
 */
global proc liquidShaderNodes_initParams( string $nodeAttr )
{
  //print ($nodeAttr+"\n");
  $node = basenameEx( $nodeAttr );
  string $shaderPath = `getAttr ($node+".rmanShaderLong")`;


  // shader does not exist / not readable
  if ( !`filetest -s $shaderPath` ) {
    warning ($shaderPath+" does not exist / is not readable");
  }

  // invalid path
  if ( !liquidGlobalsExists() ) eval("liquidCreateGlobals();select "+$node+";");
  string $extension = `getAttr "liquidGlobals.shaderExt"`;
  if ( match("[a-zA-Z]+$", $shaderPath ) != $extension ) {
    warning ("Shaders must end with "+$extension+" ");
    return;
  }

  // read shader params
  {
    // force reload
    global string $gLiquidSlShaderFile;
    $gLiquidSlShaderFile = "";
  }
  liquidSlSetShader( $shaderPath );

  // check the type
  string $shadertype = liquidSlShaderType();
  string $nodeType = nodeType( $node );
  $nodeType = tolower( $nodeType );
  if ( !gmatch( $nodeType, ("*"+$shadertype+"*") ) ) {
    string $short = basenameEx($shaderPath);
    string $typ = substitute("liquid", $nodeType, "" );
    warning ($short+" is not a "+$typ+"shader !");
    return;
  }

  string $type = nodeType($node);

  // create shader params
  liquidAttachShaderParams( $node, $shaderPath );

  // save the params description in a string array attribute
  rmanParams_create( $node, 0 );

  // delete obsolete params
  //
  global string $gLiquidSlParamNames[];
  string $allUserDefinedAttr[] = `listAttr -ud -hd $node`;
  string $obsoleteAttr[] = stringArrayRemove( $gLiquidSlParamNames, $allUserDefinedAttr );

  //print ("> all: "+stringArrayToString( $allUserDefinedAttr, ", ")+"\n");      // DBG
  //print ("> shd: "+stringArrayToString( $gLiquidSlParamNames, ", ")+"\n");     // DBG
  //print ("> end: "+stringArrayToString( $obsoleteAttr, ", ")+"\n");            // DBG

  for ( $at in $obsoleteAttr ) {
    string $fullattr = ($node+"."+$at);
    if (  $at == "rmanParams"     ||
          $at == "rmanDetails"    ||
          $at == "rmanTypes"      ||
          $at == "rmanDefaults"   ||
          $at == "rmanArraySizes" ||
          gmatch( $at, "liquid*ShaderNode")  ||
          gmatch( $at, "*Lif") ) continue;
    if ( objExists( $fullattr ) ) {
      string $connections[] = `listConnections -plugs true $fullattr`;
      for ( $c in $connections ) {
        //trace ("  disconnectAttr "+$c+" "+$fullattr);
        catch(`disconnectAttr $c $fullattr`);
      }
      string $parentAttr[] = `attributeQuery -n $node -listParent $at`;
      if ( !size($parentAttr) ) deleteAttr $fullattr;
    }
  }


  evalDeferred( "if ( `layout -q -ex \"AttrEd"+$type+"FormLayout\"` ) deleteUI \"AttrEd"+$type+"FormLayout\";");
  evalDeferred( "if ( objExists( \""+$node+"\" ) ) updateAE "+$node+";" );
}



/**
 *  preview function for the shader node
 */
global proc liquidShaderNodePreview( string $node )
{
  //print (">> liquidSurfacePreview "+$node+"\n");

  if ( !liquidGlobalsExists() ) eval("liquidCreateGlobals();select "+$node+";");

  string $nodetype = nodeType($node);
  if ( $nodetype == "liquidLight" || $nodetype == "liquidVolume" ) {
    warning "Preview is not yet supported for Liquid Light and Volume Shader.";
    return;
  }

  string $previewDir  = liquidFluidGetPreviewDir();
  string $shader      = getAttr ($node+".rmanShader");
  string $image       = ($previewDir+"/"+$node+"_"+$shader+".tif");

  // if a a previous .done file exists remove it.
  if ( `filetest -r ($image+"_"+$shader+".done")` ) sysFile -del ($image+"_"+$shader+".done");


  string $args = ( "liquidPreviewShader -shader " + $node );
  int $previewType  = `getAttr liquidGlobals.previewType`;

  int $primitive;
  if ( objExists( ($node+".previewPrimitive") ) ) {
    $primitive = `getAttr ($node+".previewPrimitive")`;
    if ( $primitive == "(globals)" ) {
    	$primitive = `getAttr liquidGlobals.previewPrimitive`;
    }
  } else {
    $primitive = `getAttr liquidGlobals.previewPrimitive`;
  }
  if( $primitive == 1 ) {
    $args += " -cube";
  } else if( $primitive == 2 ) {
    $args += " -cylinder";
  } else if( $primitive == 3 ) {
    $args += " -torus";
  } else if( $primitive == 4 ) {
    $args += " -plane";
  } else if( $primitive == 5 ) {
    $args += " -teapot";
  } else if( $primitive == 6 ) {
    $args += " -custom";
    string $customRibFile = `getAttr ($node+".previewCustomPrimitive")`;
    $args += ( " \""+$customRibFile+"\"");
  }

  string $driver = ($previewType)? `getAttr liquidGlobals.previewDisplayDriver`:"tiff";
  if( $driver != "" ) {
    $args += " -dd " + $driver;
  }

  $args += (" -dn \""+$image+"\"");

  int $type = ($previewType)? `getAttr liquidGlobals.previewConnectionType`:0;
  if( $type  == 1 ) {
    $args += " -pipe";
  }

  int $size = ($previewType)? `getAttr liquidGlobals.previewSize`:128;
  $args += " -ds " + $size;

  int $sshn = `getAttr liquidGlobals.shortShaderNames`;
  if( $sshn != 0 ) {
    $args = $args + ( " -sshn " + $sshn );
  }

  string $previewCommand = `getAttr liquidGlobals.previewRenderer`;
  if( $previewCommand != "" ) {
    $args = $args + ( " -renderer " + $previewCommand );
  }

  float $objectSize = (objExists( ($node+".previewObjectSize") ))? (`getAttr ($node+".previewObjectSize")`):1.0;
  if( $objectSize != 1.0 ) {
    $args = $args + ( " -objectSize " + $objectSize );
  }

  float $shadingRate = (objExists( ($node+".previewShadingRate") ))? (`getAttr ($node+".previewShadingRate")`):1.0;
  if( $shadingRate != 1.0 ) {
    $args = $args + ( " -shadingRate " + $shadingRate );
  }

  int $backPlane = (objExists( ($node+".previewBackplane") ))? (`getAttr ($node+".previewBackplane")`):1;
  if( $backPlane != 1 ) {
    $args = $args + ( " -noBackPlane" );
  }

  //trace ($args+"\n");
  setAttr ($node+".refreshPreview") true;
  eval( $args );

}

/**
 *  make a bigger swatch
 */
global proc liquidPreviewSwatchNew ( string $nodeName, string $msg )
{
  //// trace ("liquidPreviewSwatchNew "+$nodeName+" "+$msg);
  global int $gTextColumnWidthIndex;

  string $node[];
  tokenize($msg, ".", $node);

  string $label = nodeType($node[0]);
  if ( gmatch( $label, "*Surface*") ) $label = "surface";
  else if ( gmatch( $label, "*Displacement*") ) $label = "displacement";
  else if ( gmatch( $label, "*Volume*") ) $label = "volume";
  else if ( gmatch( $label, "*Light*") ) $label = "light";

  formLayout swatchDisplayForm;
    text -l $label swatchLabel;

    swatchDisplayPort -wh 128 128 -sn $node[0] swatchDisplay;
    button -w 70 -h 64 -l "preview" liquidAEswatchRefresh;
    button -w 70 -h 28 -l "reload" liquidAEShaderReload;
    button -w 70 -h 28 -l "edit Lif" liquidAEEditLif;

    setParent ..;
  formLayout -e
    -af  swatchLabel           top     0
    -af  swatchLabel           bottom  0
    -an  swatchLabel           left
    -aof swatchLabel           right   (-$gTextColumnWidthIndex)

    -ac  swatchDisplay         left    5   swatchLabel
    -af  swatchDisplay         top     0
    -an  swatchDisplay         right

    -af  liquidAEswatchRefresh top     -2
    -ac  liquidAEswatchRefresh left    5   swatchDisplay

    -af  liquidAEShaderReload  top     102
    -ac  liquidAEShaderReload  left    5   swatchDisplay

    -af  liquidAEEditLif       top     76
    -ac  liquidAEEditLif       left    5   swatchDisplay

    swatchDisplayForm;

  //// trace ("  liquidPreviewSwatchNew DONE");

  liquidPreviewSwatchReplace $nodeName $msg;
}

/**
 *  keep a bigger swatch
 */
global proc liquidPreviewSwatchReplace ( string $nodeName, string $msg )
{
  //// trace ("liquidPreviewSwatchReplace "+$nodeName+" "+$msg);
  string $node[];
  tokenize($msg, ".", $node);

  string $label = nodeType($node[0]);
  if ( gmatch( $label, "*Surface*") ) $label = "surface";
  else if ( gmatch( $label, "*Displacement*") ) $label = "displacement";
  else if ( gmatch( $label, "*Volume*") ) $label = "volume";
  else if ( gmatch( $label, "*Light*") ) $label = "light";

  text -e -l $label swatchLabel;
  swatchDisplayPort -edit -sn $node[0] -wh 128 128 swatchDisplay;
  button -e -c ("liquidShaderNodePreview "+$node[0]) liquidAEswatchRefresh;
  button -e -c ("liquidShaderNodes_initParams \""+$node[0]+"\";") liquidAEShaderReload;
  button -e -c ("liquidFluidEditLifFile \""+$node[0]+"\";") liquidAEEditLif;

  //// trace ("  liquidPreviewSwatchReplace DONE");
}


// AE procs

global proc liquidHideAEShaderParams( string $node)
{
  // WARNING : these are Maya global variables !!!
  // DO NOT CHANGE THEIR VALUES AT ANY POINT !!!!!
  global string	$gAEFocusNode;
  global string $gAEControlLayoutName;

  string $theNode = ($node == "")? $gAEFocusNode : $node;

  // early exit
  if ( !objExists( ($theNode+".rmanParams") ) ) {
    // trace ( "   !!!!!!!   NO rmanParams ATTRIBUTE ON "+$theNode+"  !!!!!!!!" );
    return;
  }

  layout -e -m false $gAEControlLayoutName;
  string $params[] = `getAttr ($theNode+".rmanParams")`;
  //trace ("    AE display suppress >"+$theNode);
  for ( $p in $params ) {
    //trace ("    > suppressing "+$p);
    editorTemplate -suppress $p;
  }
  editorTemplate -suppress rmanTypes;
  editorTemplate -suppress rmanDetails;
  editorTemplate -suppress rmanDefaults;
  layout -e -m true $gAEControlLayoutName;
}



/**
 *  display the shader parameters
 *  $msg contains the node.rmanShaderLong
 */
global proc liquidShaderNodesParamsNew ( string $msg )
{
  //trace ( "\n>> liquidShaderNodesParamsNew  " + $msg );
  global string $gAEControlLayoutName;

  float $st = `timerX`;

  string $theNode = basenameEx( $msg );
  string $longShaderName = `getAttr $msg`;
  string $nodeType = nodeType( $theNode );

  // invalid shader path : exit early
  if ( !`filetest -r $longShaderName` ) {
    // trace "   invalid path : exit";
    setLastAENode( $theNode, $nodeType );
    setLastAEShader( $longShaderName, $nodeType );
    return;
  }

  if ( !`waitCursor -q -st` ) waitCursor -state on;
  layout -e -m false $gAEControlLayoutName;

  // create new stuff !!
  // read the shader parameters
  //trace ( "   setting shader : " + $longShaderName );
  liquidSlSetShader( $longShaderName );


  int $i = 0;
  int $guiSize = ( liquidLifGuiSize() )? liquidLifGuiSize() : liquidSlNumParams();

  //trace ( "   creating widgets : " + $longShaderName );
  while ( $i < $guiSize ) {

    string $argType     = liquidLifParamType($i);
    string $argSubType  = liquidLifParamGuiType($i);
    int    $argArrayLen = liquidLifParamArraySize($i);

    switch( $argType ) {

      case "group":
        liquidAE_LifGrp( $theNode, $i );
        break;

      case "float":
        liquidAE_LifFloat( $theNode, $nodeType, $i, $argSubType );
        break;

      case "string":
        liquidAE_LifString( $theNode, $nodeType, $i, $argSubType );
        break;

      case "color":
        liquidAE_LifColor( $theNode, $nodeType, $i, $argSubType );
        break;

      case "point":
      case "vector":
      case "normal":
        liquidAE_LifVector( $theNode, $nodeType, $i );
        break;

      default:
        print ("    > \""+$argType+"\" not handled yet !\n");
        break;
    }

    $i++;
  }

  //trace "   updating shader AE refresh globals";
  setLastAENode( $theNode, $nodeType );
  setLastAEShader( $longShaderName, $nodeType );

  global float $gnst;
  $gnst = `timerX`;
  evalDeferred ("layout -e -m true "+$gAEControlLayoutName+";if ( `waitCursor -q -st` ) waitCursor -state off;// trace (\"   #####  New back from the dead in \"+(timerX(\"-st\", $gnst))+\" sec !  #####\\n\");" );

  string $time = `timerX -st $st`;
  // trace ("   new DONE !  ( "+$time+" sec. ) ");
}

global proc liquidShaderNodesParamsReplace ( string $msg )
{
  // trace ("\n>> liquidShaderNodesParamsReplace  \""+$msg+"\"");
  global string $gAEControlLayoutName;

  float $st = `timerX`;

  string $theNode             = basenameEx( $msg );
  string $type                = nodeType( $theNode );
  string $longShaderName      = getAttr( $msg );
  string $lastDisplayedNode   = getLastAENode( $type );
  string $lastDisplayedShader = getLastAEShader( $type );

  if ( !`waitCursor -q -st` ) waitCursor -state on;
  layout -e -m false $gAEControlLayoutName;

  if ( $theNode == $lastDisplayedNode && $longShaderName == $lastDisplayedShader ) {
    /* trace "\n   same node + same shader -> doing nothing";
    trace ("   > "+$theNode+" == "+$lastDisplayedNode);
    trace ("   > "+$longShaderName+" == "+$lastDisplayedShader); */
    evalDeferred ("layout -e -m true "+$gAEControlLayoutName+";");
  }

  if ( $theNode != $lastDisplayedNode && $longShaderName == $lastDisplayedShader ) {
    /* trace "\n   different node + same shader -> relinking controls";
    trace ("   > "+$theNode+" != "+$lastDisplayedNode);
    trace ("   > "+$longShaderName+" == "+$lastDisplayedShader); */

    liquidSlSetShader( $longShaderName );

    int $i = 0;
    int $guiSize = ( liquidLifGuiSize() )? liquidLifGuiSize() : liquidSlNumParams();

    while ( $i < $guiSize ) {

      string $argType     = liquidLifParamType($i);
      string $argSubType  = liquidLifParamGuiType($i);
      int    $argArrayLen = liquidLifParamArraySize($i);

      switch( $argType ) {

        case "float":
          liquidAE_LifFloat( $theNode, $type, $i, $argSubType );
          break;

        case "string":
          liquidAE_LifString( $theNode, $type, $i, $argSubType );
          break;

        case "color":
          liquidAE_LifColor( $theNode, $type, $i, $argSubType );
          break;

        case "point":
        case "vector":
        case "normal":
          liquidAE_LifVector( $theNode, $type, $i );
          break;

        default:
          break;
      }

      $i++;
    }
    evalDeferred ("liquidHideAEShaderParams "+$theNode+";");
    evalDeferred ("layout -e -m true "+$gAEControlLayoutName+";");
  }

  if ( $theNode != $lastDisplayedNode && $longShaderName != $lastDisplayedShader ) {
    /* trace "\n   different node + different shader -> rebuilding controls";
    trace ("   > "+$theNode+" != "+$lastDisplayedNode);
    trace ("   > "+$longShaderName+" != "+$lastDisplayedShader); */
    evalDeferred ("if ( `layout -q -ex AttrEd"+$type+"FormLayout` ) deleteUI AttrEd"+$type+"FormLayout;");
    evalDeferred ("liquidHideAEShaderParams "+$lastDisplayedNode+";");
    evalDeferred ("liquidShaderNodesParamsNew "+$theNode+".rmanShader;");
    evalDeferred ("updateAE "+$theNode+";layout -e -m true "+$gAEControlLayoutName+";");
  }

  if ( $theNode == $lastDisplayedNode && $longShaderName != $lastDisplayedShader ) {
    /* trace   "\n   same node + different shader -> rebuilding controls";
    trace ("   > "+$theNode+" == "+$lastDisplayedNode);
    trace ("   > "+$longShaderName+" != "+$lastDisplayedShader); */
    evalDeferred ("layout -e -m true "+$gAEControlLayoutName+";");
  }

  setLastAENode( $theNode, $type );
  setLastAEShader( $longShaderName, $type );
  liquidHideAEShaderParams( $theNode );

  global float $grst;
  $grst = `timerX`;
  evalDeferred ("layout -e -m true "+$gAEControlLayoutName+";if ( `waitCursor -q -st` ) waitCursor -st off;// trace (\"   #####  Replace back from the dead in \"+(timerX(\"-st\", $grst))+\" sec !  #####\\n\");" );

  string $time = `timerX -st $st`;
  // trace ("   replace DONE !  ( "+$time+" sec. )\n");
}


global proc liquidShaderPickerNew( string $nodeName, string $msg )
{
  if ( !liquidGlobalsExists() ) liquidCreateGlobals();

  string $node[] = stringToStringArray( $msg, ".");
  $ctlName = ( "liquidShader_" + $node[1] );

  string $shaderDir  = getAttr("liquidGlobals.fluidShaderBrowserDefaultPath");
  if ( !gmatch( $shaderDir, "/*") ) $shaderDir = (`workspace -q -rd` + $shaderDir);

  string $myFileCommand = ( "{\n"
                            + "string $v = `getAttr "+$msg+"`+\"\";"
                            + "liquidChangeTextFileAttrPlus " + $node[0] + " " + $node[1] + " " + $ctlName + " \"" + $shaderDir + "\" (\"*.\"+" + "`getAttr(\"liquidGlobals.shaderExt\")`" + ");"
                            + "if ( `getAttr "+$msg+"`+\"\" != $v ) evalDeferred(\"liquidShaderNodes_initParams " + $node[0] + "\");"
                            + "}");
  string $form          = `formLayout`;

  setUITemplate -pst attributeEditorTemplate;
  string $fullCtlPath   = `textFieldGrp -label "Shader" -adj 2 $ctlName`;
  connectControl -index 2 $fullCtlPath $msg;
  string $button = `iconTextButton -style "iconOnly" -w 29 -h 19 -mw 0 -mh 0 -i "lif_shd.xpm" -c $myFileCommand ($ctlName+"_button")`;
  setParent ..;

  if (`about -mac`) {
     formLayout  -e
                -af $ctlName  top     0
                -af $ctlName  left    0
                -af $ctlName  right   31
                -af $button   top     2
                -af $button   right   5
                $form;
  } else {
    formLayout  -e
                -af $ctlName  top     0
                -af $ctlName  left    0
                -af $ctlName  right   31
                -af $button   top     2
                -ac $button   left    0 $ctlName
                $form;
  }

  setUITemplate -ppt;
}

global proc liquidShaderPickerReplace( string $nodeName, string $msg )
{
  if ( !liquidGlobalsExists() ) liquidCreateGlobals();

  string $node[] = stringToStringArray( $msg, ".");
  $ctlName = ( "liquidShader_" + $node[1] );

  string $shaderDir  = getAttr("liquidGlobals.fluidShaderBrowserDefaultPath");
  if ( !gmatch( $shaderDir, "/*") ) $shaderDir = (`workspace -q -rd` + $shaderDir);

  string $myFileCommand = (   "{\n"
                            + "string $v = `getAttr "+$msg+"`+\"\";"
                            + "liquidChangeTextFileAttrPlus " + $node[0] + " " + $node[1] + " " + $ctlName + " \"" + $shaderDir + "\" (\"*.\"+" + "`getAttr(\"liquidGlobals.shaderExt\")`" + ");"
                            + "if ( `getAttr "+$msg+"`+\"\" != $v ) evalDeferred(\"liquidShaderNodes_initParams " + $node[0] + "\");"
                            + "}");
  connectControl -index 2 $ctlName $msg;
  iconTextButton -e -c $myFileCommand ($ctlName+"_button");
}

/**
 *  modified lif procedures to create the attribute editor widgets.
 */

global proc liquidAE_LifFloat_slider( string $selectedObj, string $nodeType, string $paramName, int $index, string $label, string $range[], string $description )
{
  //trace ("       - liquidAE_LifFloat_slider "+$selectedObj+" "+$paramName+" "+$index+" "+$label+" "+$range[0]+" "+$range[1]+" "+$description);

  setUITemplate -pst attributeEditorTemplate;

  string $theParam    = ( $index < 0 )? $paramName : ( $paramName + "[" + $index + "]" );
  string $theParamCtl = ( $index < 0 )? ( $nodeType + "_" + $paramName + "_0" ) : ( $nodeType + "_" + $paramName + "_" + $index );
  string $theLabel    = ( $index < 0 )? $label : ( $label + "[" + $index + "]" );

  float $min    = $range[0];
  float $max    = $range[1];
  float $slmin  = $range[0];
  float $slmax  = $range[1];

  if ( $min == $max ) {
    $min    = -100000000;
    $max    =  100000000;
    float $val = ( $index < 0 )? `getAttr ($selectedObj+"."+$paramName)` : `getAttr ($selectedObj+"."+$paramName+"["+$index+"]")`;
    $slmin  =  ( $val > 0 )? 0 : $val * 2;
    $slmax  =  ( $val > 0 )? $val * 2 : 0;
  }

  if ( !`control -q -ex ($theParamCtl+"_LIF")` ) {
    //trace ("       - created ctl "+$theParamCtl+"_LIF");
    attrFieldSliderGrp  -label  $theLabel
                        -ann    $description
                        -fieldMinValue  $min      -fieldMaxValue  $max
                        -minValue $slmin            -maxValue  $slmax
                        -sliderMinValue $slmin    -sliderMaxValue $slmax
                        -at ( $selectedObj + "." + $theParam )
                        -cc ( "liquidParamAU " + $selectedObj)
                        -hideMapButton true
                        ($theParamCtl+"_LIF");
  } else {
    attrFieldSliderGrp  -e
                        -ann    $description
                        -at ( $selectedObj + "." + $theParam )
                        -fieldMinValue  $min      -fieldMaxValue  $max
                        -minValue $slmin          -maxValue  $slmax
                        -sliderMinValue $slmin    -sliderMaxValue $slmax
                        -cc ( "liquidParamAU " + $selectedObj)
                        ($theParamCtl+"_LIF");
  }

  setUITemplate -ppt;
}

global proc liquidAE_LifFloat_selector( string $selectedObj, string $nodeType, string $paramName, string $label, string $range[], string  $description )
{
  setUITemplate -pst attributeEditorTemplate;

  string $theParamCtl = ($nodeType+"_"+$paramName+"_LIF");

  if ( !`control -q -ex $theParamCtl` ) {
    optionMenuGrp -label $label $theParamCtl;

    int $numSize = size( $range );
    for ( $k = 0; $k < $numSize; $k = $k + 2 ) {
      int $data = $range[ $k+1 ];
      menuItem -l $range[ $k ] -data $data;
    }
  }

  optionMenuGrp -e -ann $description $theParamCtl;
  connectControl -index 2 $theParamCtl ($selectedObj+"."+$paramName);

  setUITemplate -ppt;
}

global proc liquidAE_LifFloat_bool( string $selectedObj, string $nodeType, string $paramName, string $label, string $range[], string  $description )
{
  setUITemplate -pst attributeEditorTemplate;

  string $theParamCtl = ($nodeType+"_"+$paramName+"_LIF");

  if ( !`control -q -ex $theParamCtl` ) checkBoxGrp -label $label $theParamCtl;
  checkBoxGrp -e -ann $description $theParamCtl;
  connectControl -index 2 $theParamCtl ($selectedObj+"."+$paramName);

  setUITemplate -ppt;
}

global proc liquidAE_LifFloat_spline( string $selectedObj, string $nodeType, string $paramName, string $label, string $subtype, string $description )
{
  // find which attributes are going to be connected to the widget
  string $attributes[] = stringToStringArray( $subtype, " ");
  string $valueAttr    = $attributes[1];
  string $positionAttr = $attributes[2];
  string $interpAttr   = $attributes[3];

  string $compound    = lifGradientAttr_create( $selectedObj, $valueAttr, $positionAttr, $interpAttr );
  string $shader = getAttr ($selectedObj+".rmanShader");
  string $lifCtlName  = ( $shader + "__" + $compound + "Ramp" );

  if ( !`gradientControl -q -ex $lifCtlName` ) {
    // create the control
    int $staticPositions = 1 - min( 1.0, float(size( $positionAttr )) );
    lifGradient_create( ($selectedObj+"."+$compound), 0, 0, 1, $staticPositions, 0 );
  } else {
    // connect the control
    lifGradient_connect( ($selectedObj+"."+$compound) );
  }

}

global proc liquidAE_LifFloat( string $selectedObj, string $nodeType, int $index, string $subtype )
{
  string $paramName   = liquidLifParamName($index);
  int    $arraySize   = liquidLifParamArraySize( $index );
  int    $channelBox  = liquidLifChannelBoxState( $index );

  // error checking : if the param does not exist, we might have a bad lif
  if ( ! objExists( ($selectedObj+"."+$paramName) ) ) return;

  string $label       = liquidLifParamLabel( $index );
  string $range[]     = liquidLifParamGuiRange( $index );

  string $description = liquidLifParamDescription( $index );
  string $shortSubType[] = stringToStringArray( $subtype, " ");

  //trace ("     + liquidAE_LifFloat "+$selectedObj+" "+$nodeType+" "+$index+" "+$subtype);

  switch( $shortSubType[0] ) {


    case "slider":
      if ( $arraySize ) {

        int $skip = `control -q -ex ($nodeType+"_"+$paramName+"_0_LIF")`;
        if ( !$skip ) {
          frameLayout -label ($paramName+"["+$arraySize+"]") -borderVisible false -labelIndent 10 -font "smallPlainLabelFont";
          columnLayout;
        }

        int $j;
        for ( $j=0; $j<$arraySize; $j++ ) {
          liquidAE_LifFloat_slider( $selectedObj, $nodeType, $paramName, $j, $label, $range, $description );
        }

        if ( !$skip ) {
          setParent ..;
          setParent ..;
        }

      } else liquidAE_LifFloat_slider( $selectedObj, $nodeType, $paramName, -1, $label, $range, $description );

      break;

    case "selector":
      if ( $arraySize ) {

      } else liquidAE_LifFloat_selector( $selectedObj, $nodeType, $paramName, $label, $range, $description );
      break;


    case "bool":
      if ( $arraySize ) {

      } else liquidAE_LifFloat_bool( $selectedObj, $nodeType, $paramName, $label, $range, $description );
      break;

    case "floatspline":
    if ( $arraySize ) {
      liquidAE_LifFloat_spline( $selectedObj, $nodeType, $paramName, $label, $subtype, $description );
    }
    break;

    default:
      if ( $arraySize > 0 ) {

        int $skip = `control -q -ex ($nodeType+"_"+$paramName+"_0_LIF")`;
        if ( !$skip ) {
          frameLayout -label ($paramName+"["+$arraySize+"]") -borderVisible false -labelIndent 10 -font "smallPlainLabelFont";
          columnLayout ;
        }

        int $j;
        for ( $j=0; $j<$arraySize; $j++ ) {
          liquidAE_LifFloat_slider( $selectedObj, $nodeType, $paramName, $j, $label, $range, $description );
        }

        if ( !$skip ) {
          setParent ..;
          setParent ..;
        }

      } else {
        liquidAE_LifFloat_slider( $selectedObj, $nodeType, $paramName, -1, $label, $range, $description );
      }
      break;
  }

  setAttr -k $channelBox ($selectedObj+"."+$paramName);

  //print "Done\n";
}

global proc liquidAE_LifString( string $selectedObj, string $nodeType, int $index, string $subtype )
{
  setUITemplate -pst attributeEditorTemplate;

  string $paramName = liquidLifParamName($index);
  if ( ! objExists( ($selectedObj+"."+$paramName) ) ) return;

  int    $arraySize     = liquidLifParamArraySize( $index );
  string $label         = liquidLifParamLabel( $index );
  string $range[]       = liquidLifParamGuiRange( $index );
  string $description   = liquidLifParamDescription( $index );

  int $j;
  int $size = ( $arraySize > 0 )? $arraySize:1;
  int $skip = (`control -q -ex (( $nodeType + "_" + $paramName + "_0_LIF" ))`) || ( $subtype == "selector" );

  if ( $arraySize && !$skip ) {
    frameLayout -label ($paramName+"["+$arraySize+"]") -borderVisible false -labelIndent 10 -font "smallPlainLabelFont";
    columnLayout ;
  }

  for ( $j=0; $j<$size; $j++ ) {

    string $attr          = ($arraySize)? ($paramName+"["+$j+"]"):$paramName;
    string $theLabel      = ($arraySize)? ($label+"["+$j+"]"):$label;
    string $currentValue  = `getAttr ( $selectedObj + "." + $attr )`;
    string $ctlName       = ( $nodeType + "_" + $paramName + "_" + $j + "_LIF" );


      switch( $subtype ) {

        case "texture":
          string $myFileCommand = ( "liquidChangeTextFileAttr " + $selectedObj + " " + $attr + " " + $ctlName );
          if ( !`control -q -ex $ctlName` ) {
            string $form          = `formLayout`;
            string $fullCtlPath   = `textFieldGrp -label $theLabel $ctlName`;
            liquidAddTextureViewerMenu( $fullCtlPath );
            string $button = `iconTextButton -style "iconOnly" -w 29 -h 19 -mw 0 -mh 0 -i "lif_tex.xpm" ($ctlName+"_BUT")`;
            setParent ..;

            if (`about -mac`) {
              formLayout  -e
                          -af $ctlName  top     0
                          -af $ctlName  left    0
                          -af $ctlName  right   31
                          -af $button   top     2
                          -af $button   right   5
                          $form;
            } else {
              formLayout  -e
                          -af $ctlName  top     0
                          -af $ctlName  left    0
                          -af $ctlName  right   31
                          -af $button   top     2
                          -ac $button   left    0 $ctlName
                          $form;
            }
          }
          iconTextButton -e -c $myFileCommand ($ctlName+"_BUT");
          textFieldGrp -e -ann $description $ctlName;
          connectControl -index 2 $ctlName ($selectedObj+"."+$attr);

          break;

        case "shadow":
          string $myFileCommand = ( "liquidChangeTextFileAttr " + $selectedObj + " " + $attr + " " + $ctlName );
          if ( !`control -q -ex $ctlName` ) {
            string $form          = `formLayout`;
            textFieldGrp -label $theLabel $ctlName;
            liquidAddTextureViewerMenu( $ctlName );
            string $button = `iconTextButton -style "iconOnly" -w 29 -h 19 -mw 0 -mh 0 -i "lif_shd.xpm" -c $myFileCommand ($ctlName+"_BUT")`;
            setParent ..;

            if (`about -mac`) {
              formLayout  -e
                          -af $ctlName  top     0
                          -af $ctlName  left    0
                          -af $ctlName  right   31
                          -af $button   top     2
                          -af $button   right   5
                          $form;
            } else {
              formLayout  -e
                          -af $ctlName  top     0
                          -af $ctlName  left    0
                          -af $ctlName  right   31
                          -af $button   top     2
                          -ac $button   left    0 $ctlName
                          $form;
            }

          }
          iconTextButton -e -c $myFileCommand ($ctlName+"_BUT");
          textFieldGrp -e -ann $description $ctlName;
          connectControl -index 2 $ctlName ($selectedObj+"."+$attr);
          break;

        case "coordsys":
          string $myFileCommand = ( "liquidLifCoordSysBrowser " + $selectedObj + " " + $attr + " " + $ctlName );
          if ( !`control -q -ex $ctlName` ) {
            string $form          = `formLayout`;
            textFieldGrp  -label $theLabel $ctlName;
            string $button = `iconTextButton -style "iconOnly" -w 29 -h 19 -mw 0 -mh 0 -i "lif_cs.xpm" -c $myFileCommand ($ctlName+"_BUT")`;
            setParent ..;

            if (`about -mac`) {
              formLayout  -e
                          -af $ctlName  top     0
                          -af $ctlName  left    0
                          -af $ctlName  right   31
                          -af $button   top     2
                          -af $button   right   5
                          $form;
            } else {
              formLayout  -e
                          -af $ctlName  top     0
                          -af $ctlName  left    0
                          -af $ctlName  right   31
                          -af $button   top     2
                          -ac $button   left    0 $ctlName
                          $form;
            }
          }
          iconTextButton -e -c $myFileCommand ($ctlName+"_BUT");
          textFieldGrp  -e -ann $description $ctlName;
          connectControl -index 2 $ctlName ($selectedObj+"."+$attr);
          break;

        case "selector":
          if ( !`control -q -ex $ctlName` ) {
            optionMenuGrp -label $label $ctlName;
            int $numSize = size( $range );
            for ( $k = 0; $k < $numSize; $k = $k + 2 ) {
              menuItem -l $range[ $k ];
            }
            optionMenuGrp -e -v (`getAttr ($selectedObj+"."+$attr)`) $ctlName;
          }
          string $myCommand = ("setAttr -type \"string\" \""+$selectedObj+"."+$attr+"\" (`optionMenuGrp -q -v "+$ctlName+"`);");
          optionMenuGrp -e -cc $myCommand -ann $description $ctlName;
          break;

        default:
          if (  !`control -q -ex $ctlName` ) textFieldGrp -label $theLabel $ctlName;
          textFieldGrp -e -ann $description$ctlName;
          connectControl -index 2 $ctlName ($selectedObj+"."+$attr);
          break;
      }
  }
  if ( $arraySize && !$skip ) {
    setParent ..;setParent ..;
  }
  setUITemplate -ppt;
}




global proc liquidAE_LifColor_spline( string $selectedObj, string $nodeType, int $index, string $subtype )
{
  // find which attributes are going to be connected to the widget
  string $attributes[] = stringToStringArray( $subtype, " ");
  string $colorAttr    = $attributes[1];
  string $positionAttr = $attributes[2];
  string $interpAttr   = $attributes[3];

  setUITemplate -pst attributeEditorTemplate;

  string $paramName   = liquidLifParamName($index);
  int    $arraySize  = liquidLifParamArraySize( $index );
  if ( ! objExists( ($selectedObj+"."+$paramName) ) ) return;

  string $label       = liquidLifParamLabel($index);
  string $description = liquidLifParamDescription( $index );
  int    $arraySize   = liquidLifParamArraySize( $index );
  int    $channelBox  = liquidLifChannelBoxState( $index );

  string $compound    = lifGradientAttr_create( $selectedObj, $colorAttr, $positionAttr, $interpAttr );
  string $shader = getAttr ($selectedObj+".rmanShader");
  string $lifCtlName  = ( $shader + "__" + $compound + "Ramp" );

  if ( !`gradientControl -q -ex $lifCtlName` ) {
    // create the control
    int $staticPositions = 1 - min( 1.0, float(size( $positionAttr )) );
    lifGradient_create( ($selectedObj+"."+$compound), 0, 0, 1, $staticPositions, 0 );
  } else {
    // connect the control
    lifGradient_connect( ($selectedObj+"."+$compound) );
  }

  setUITemplate -ppt;
}

global proc liquidAE_LifColor( string $selectedObj, string $nodeType, int $index, string $subtype )
{
  if ( gmatch( $subtype, "colorspline*") && liquidLifParamArraySize( $index ) ) {
    liquidAE_LifColor_spline( $selectedObj, $nodeType, $index, $subtype );
    return;
  }

  setUITemplate -pst attributeEditorTemplate;

  string $paramName   = liquidLifParamName($index);
  int    $arraySize  = liquidLifParamArraySize( $index );
  if ( ! objExists( ($selectedObj+"."+$paramName) ) ) return;

  string $label       = liquidLifParamLabel($index);
  string $description = liquidLifParamDescription( $index );
  int    $arraySize   = liquidLifParamArraySize( $index );
  int    $channelBox  = liquidLifChannelBoxState( $index );

  int $i;
  int $nValues = ($arraySize)? $arraySize : 1;
  int $skip    = `control -q -ex ( ( $arraySize )? ($nodeType+"_"+$paramName + "_0_LIF" ) : ($nodeType+"_"+$paramName+"_LIF" ) )`;

  if ( $arraySize && !$skip ) {
    frameLayout -label ($paramName+"["+$arraySize+"]")
                -borderVisible false
                -labelIndent 10
                -font "smallPlainLabelFont";
    columnLayout;
  }

  setAttr -k $channelBox ($selectedObj+"."+$paramName);

  for ( $i=0; $i<$nValues; $i++ ) {

    string $pname     = ( $arraySize )? ( $paramName + "[" + $i + "]") : $paramName;
    string $pnameCtl  = ( $arraySize )? ( $nodeType + "_" + $paramName + "_" + $i + "_LIF" ) : ( $nodeType + "_" + $paramName + "_LIF" );
    string $plabel    = ( $arraySize )? ( $label + "[" + $i + "]") : $label;

    string $attr      = ( $selectedObj + "." + $pname );

    if ( !`control -q -ex $pnameCtl` ) attrColorSliderGrp -label $plabel
                                                          -at $attr
                                                          -sb false
                                                          $pnameCtl;
    else attrColorSliderGrp -e -at $attr $pnameCtl;

    string $subPname = ( $arraySize )? ($pname+"."+$paramName) : ($pname);
    setAttr -k $channelBox ($selectedObj+"."+$pname);
    setAttr -k $channelBox ($selectedObj+"."+$subPname+"a");
    setAttr -k $channelBox ($selectedObj+"."+$subPname+"b");
    setAttr -k $channelBox ($selectedObj+"."+$subPname+"c");

  }

  if ( $arraySize && !$skip ) {
    setParent ..;setParent ..;
  }

  setUITemplate -ppt;
}


global proc liquidAE_LifVector( string $selectedObj, string $nodeType, int $index )
{
  setUITemplate -pst attributeEditorTemplate;

  string $paramName  = liquidLifParamName($index);
  int    $arraySize  = liquidLifParamArraySize( $index );

  if ( ! objExists( ($selectedObj+"."+$paramName) ) ) return;

  string $label       = liquidLifParamLabel($index);
  string $description = liquidLifParamDescription( $index );
  int    $arraySize   = liquidLifParamArraySize( $index );
  int    $channelBox  = liquidLifChannelBoxState( $index );

  int $i;
  int $nValues = ($arraySize)? $arraySize : 1;
  int $skip    = `control -q -ex ( ( $arraySize )? ( $nodeType + "_" + $paramName + "_0_LIF" ) : ( $nodeType + "_" + $paramName+"_LIF" ) )`;

  if ( $arraySize && !$skip ) {

    frameLayout -label ( $paramName + "[" + $arraySize + "]" )
                -borderVisible false
                -labelIndent 10
                -font "smallPlainLabelFont";
    columnLayout;

  }

  setAttr -k $channelBox ($selectedObj+"."+$paramName);

  for ( $i=0; $i<$nValues; $i++ ) {

    string $pname     = ( $arraySize )? ( $selectedObj + "." + $paramName + "[" + $i + "]" ) : ( $selectedObj + "." + $paramName );
    string $pnameCtl  = ( $arraySize )? ( $nodeType + "_" + $paramName + "_" + $i + "_LIF" ) : ( $nodeType + "_" + $paramName + "_LIF" );
    string $plabel    = ( $arraySize )? ( $label + "[" + $i + "]" ) : $label;

    if ( !`control -q -ex $pnameCtl` ) {
      attrFieldGrp  -label $plabel
                    -cc ( "liquidParamAU " + $selectedObj )
                    -attribute $pname
                    $pnameCtl;
    } else attrFieldGrp -e -attribute $pname -ann $description $pnameCtl;

    string $subPname = ( $arraySize )? ($pname+"."+$paramName) : ($pname);
    setAttr -k $channelBox $pname;
    setAttr -k $channelBox ($subPname+"a");
    setAttr -k $channelBox ($subPname+"b");
    setAttr -k $channelBox ($subPname+"c");

  }


  if ( $arraySize && !$skip ) {
    setParent ..;
    setParent ..;
  }





  setUITemplate -ppt;
}

global proc liquidAE_LifGrp( string $selectedObj, int $index )
{
  setUITemplate -pst attributeEditorTemplate;

  string $label = liquidLifParamLabel( $index );
  //print ("Grp : "+$label+"\n");

  int $state = ( gmatch( $label, "*+") )? 0:1;

  $label = substring($label, 1, size( $label ) - 1 );

  switch( $label ) {
    case "end":
      setParent ..;
      setParent ..;
      break;
    default:
      frameLayout -l $label;
      columnLayout;
      break;
  }

  setUITemplate -ppt;
}


/**
 *  Build the custom primitive menu in the attribute editor.
 */
proc liquidShaderNodesCustomPrimitiveBuildCustomMenu( string $parent, string $nodeDotAttr )
{
  // get the list of available rib files in $LIQUIDHOME/previewRibFiles
  string $ribPath = liquidGetHome() + "/previewRibFiles/";
  string $files[] = `getFileList -fld $ribPath -fs "*.rib"`;

  // remove previous menu items
  string $items[] = `optionMenuGrp -q -ill ($parent)`;
  for ( $it in $items ) deleteUI $it;

  // build the menu
  string $oldParent = `setParent -q`;
  string $fullParentPath = `setParent $parent`;

  string $currentCustomPrimitive = basenameEx(`getAttr $nodeDotAttr`);
  int $currentCustomPrimitiveIsListed = 0;

  // the list of rib files is stored in optionVars
  if ( `optionVar -ex "liquidCustomPrimitives"` ) optionVar -clearArray "liquidCustomPrimitives";

  for ( $f in $files ) {
    string $label = basenameEx( $f );
    if ( $f == $currentCustomPrimitive ) $currentCustomPrimitiveIsListed = 1;
    menuItem -p ($fullParentPath+"|OptionMenu") -l $label;
    optionVar -sva "liquidCustomPrimitives" ($ribPath+$f);
  }
  if ( !size( $files ) ) menuItem -p ($fullParentPath+"|OptionMenu") -l "none";
  setParent $oldParent;

  // set the menu to the attribute's current value
  if ( $currentCustomPrimitiveIsListed ) optionMenuGrp -e -v (basenameEx($currentCustomPrimitive)) $parent;
  else setAttr -type "string" $nodeDotAttr ($ribPath+$files[0]);
}


global proc liquidShaderNodesCustomPrimitiveNew( string $nodeDotAttr )
{
  string $nodeType = nodeType( $nodeDotAttr );
  string $cltName = ($nodeType+"_previewCustomPrimitive");

  if ( !`optionMenuGrp -q -ex $cltName` ) {

    setUITemplate -pst attributeEditorTemplate;
    optionMenuGrp -l "Custom Primitive" $cltName;
    setUITemplate -ppt;

  }

  liquidShaderNodesCustomPrimitiveReplace( $nodeDotAttr );
}


global proc liquidShaderNodesCustomPrimitiveReplace( string $nodeDotAttr )
{
  string $nodeType = nodeType( $nodeDotAttr );
  string $cltName = ($nodeType+"_previewCustomPrimitive");

  if ( `optionMenuGrp -q -ex $cltName` ) {

    liquidShaderNodesCustomPrimitiveBuildCustomMenu( $cltName, $nodeDotAttr );

    string $node[];
    tokenize $nodeDotAttr "." $node;
    string $cmd = ( "{string $files[] = `optionVar -q liquidCustomPrimitives`;"+
                    "int $sel = `optionMenuGrp -q -sl "+$cltName+"`;"+
                    "setAttr -type \"string\" "+$nodeDotAttr+" $files[$sel-1];}");
    optionMenuGrp -e -cc $cmd $cltName;
  }
  //trace ("liquidShaderNodesCustomPrimitiveReplace( "+ $nodeDotAttr +" )");
}





/**
 *  proc to attach a ribbox node to selected objects
 */

global proc liquidAssignRibboxToSelected( string $node )
{
  string $selected[] = `ls -transforms -sl`;
  for ( $sel in $selected ) {
    if ( !`attributeQuery -node $sel -ex "liqRIBBox"` ) {
      addAttr -ln "liqRIBBox" -dt "string" $sel;
    }
    connectAttr -f ($node+".ribbox") ($sel+".liqRIBBox");
  }
}

global proc liquidSelectAssignedToRibbox( string $node )
{
  select (`listConnections ($node+".ribbox")`);
}


/**
 *  proc to attach a ribbox node to selected objects
 */

global proc liquidAssignLightShaderToSelected( string $node )
{
  string $selected[] = `ls -lights -sl`;
  if ( !size( $selected ) ) $selected = `ls -transforms -sl`;
  //trace ("selected : "+stringArrayToString( $selected, " "));

  for ( $sel in $selected ) {
    if ( nodeType($sel) == "transform" ) {
      string $shapes[] = `listRelatives -c -type light $sel`;
      if ( size( $shapes ) ) $sel = $shapes[0];
      else continue;
    }

    if ( !objExists( ($sel+".liquidLightShaderNode") ) ) {
      addAttr -ln liquidLightShaderNode -at message $sel;
    }

    connectAttr -f ($node+".assignedObjects") ($sel+".liquidLightShaderNode");
  }
}

global proc liquidSelectAssignedToLightShader( string $node )
{
  select (`listConnections ($node+".assignedObjects")`);
}



/**
 *  update all nodes for the AE optimization.
 */
global proc liquidShaderUpdater( int $force )
{
  //trace ("liquidShaderUpdater( "+$force+" )");
  string $shaderNodes[] = `ls -type liquidSurface -type liquidDisplacement -type liquidVolume -type liquidLight`;
  if ( !size( $shaderNodes ) ) {
    trace "nothing";
    return;
  }
  for ( $node in $shaderNodes ) {
    string $longShaderName = `getAttr ($node+".rmanShaderLong")`;
    if ( !`filetest -r $longShaderName` ) error("liquidShaderUpdater : could not find shader \""+$longShaderName+"\"");
    int $numParams = size( `getAttr ($node+".rmanParams")` );
    if ( $force ||
        size( `getAttr ($node+".rmanDetails")` ) != $numParams ||
        size( `getAttr ($node+".rmanTypes")` ) != $numParams ||
        size( `getAttr ($node+".rmanDefaults")` ) != $numParams ||
        size( `getAttr ($node+".rmanArraySizes")` ) != $numParams
       ) {
      trace ("liquidShaderUpdater : updating liquid shader "+$node);
      rmanParams_create( $node, 1 );
    }
  }
}


{
  string $jobs[] = `scriptJob -lj`;
  for ( $j in $jobs ) {
    if ( gmatch( $j, "*liquidShaderUpdater*") ) scriptJob -kill (int(match("[0-9]+", $j))) -force;
  }
  scriptJob -event "SceneOpened" "evalDeferred(\"liquidShaderUpdater 0\")" -protected;
}

