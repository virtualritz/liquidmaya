//
//
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the 
// "License"); you may not use this file except in compliance with the License. You may 
// obtain a copy of the License at http://www.mozilla.org/MPL/ 
// 
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT 
// WARRANTY OF ANY KIND, either express or implied. See the License for the specific 
// language governing rights and limitations under the License. 
//
// The Original Code is the Liquid Rendering Toolkit. 
// 
// The Initial Developer of the Original Code is Colin Doncaster. Portions created by 
// Colin Doncaster are Copyright (C) 2002. All Rights Reserved. 
// 
// Contributor(s): Berj Bannayan. 
//
// 
// The RenderMan (R) Interface Procedures and Protocol are:
// Copyright 1988, 1989, Pixar
// All Rights Reserved
//
//
// RenderMan (R) is a registered trademark of Pixar
//
//  Creation Date:    July 8, 2003
//
//  Procedure Name:
//      liquidSlParseSlo
//
//  Description:
//      Procedure called by liquidSlSetShader() to parse
//      a prman .slo shader file.  All parsed information
//      is stored in the following global variables later
//      used by the various liquidSl* routines:
//
//          global string $gLiquidSlShaderType;
//          global int    $gLiquidSlNumParams;
//          global string $gLiquidSlParamNames[];
//          global string $gLiquidSlParamTypes[];
//          global string $gLiquidSlParamDefaults[];
//          global int    $gLiquidSlParamArraySizes[];
//
//


//////////////////////////////////////////////////////////////////////////////
//
// Local helper procedures
//

proc string
getShaderType( int $fid )
{
    string $type = "";

    // The first word on the first non-empty
    // line is the shader type.

    string $tokens[];
    string $line = `fgetline $fid`;
    while ( ! `feof $fid` )
    {
        clear( $tokens );
        tokenize $line $tokens;
        $type = $tokens[0];
        if ( $type != "" ) break;
        $line = `fgetline $fid`;
    }

    return $type;
}

proc string
getParamName( string $line )
{
    string $strip = `substitute "^[^\"]*\"" $line ""`;
    if ( $strip == $line ) return "";

    string $name = `substitute "\".*$" $strip ""`;
    if ( $name == $strip ) return "";

    return $name;
}

proc string
getParamType( string $line )
{
    string $prefix = "\"[^\"]*parameter *[uniformvaryg]+ *";

    if      ( `match ($prefix+"string") $line` != "" ) return "string";
    else if ( `match ($prefix+"float")  $line` != "" ) return "float";
    else if ( `match ($prefix+"color")  $line` != "" ) return "color";
    else if ( `match ($prefix+"point")  $line` != "" ) return "point";
    else if ( `match ($prefix+"vector") $line` != "" ) return "vector";
    else if ( `match ($prefix+"normal") $line` != "" ) return "normal";
    else if ( `match ($prefix+"matrix") $line` != "" ) return "matrix";

    return "";
}

proc int
getParamArraySize( string $line )
{
    string $strip = `substitute "^.*[a-z]\\[" $line ""`;
    if ( $strip == $line ) return 0;

    string $sizeStr = `substitute "\\].*$" $strip ""`;
    if ( $sizeStr == $strip ) return 0;

    int $sizeInt = $sizeStr;
    return $sizeInt;
}

proc string
getParamDefaultF( int $fid )
{
    string $default = "0.0";
    string $line = strip( `fgetline $fid` );

    // First check for "Unknown"
    if ( `match "Unknown" $line` != "" )
        return $default;

    // Strip everything ahead of the default
    string $strip = `substitute "^.*[Dd]efault value: *" $line ""`;
    if ( $strip != $line )
        $default = $strip;

    return $default;
}

proc string
getParamDefaultS( int $fid )
{
    string $default = "";
    string $line = strip( `fgetline $fid` );

    // First check for "Unknown"
    if ( `match "Unknown" $line` != "" )
        return $default;

    // Strip everything ahead of the default
    // (leaving the double-quotes around it)
    string $strip = `substitute "^.*[Dd]efault value: *" $line ""`;
    if ( $strip != $line )
        $default = $strip;

    return $default;
}

proc string
getParamDefaultM( int $fid )
{
    string $default = ( "<<0, 0, 0, 0; " +
                        "0, 0, 0, 0;" +
                        "0, 0, 0, 0;" +
                        "0, 0, 0, 0>>" );

    string $line = `fgetline $fid`;

    // First check for "Unknown"
    if ( `match "Unknown" $line` != "" )
        return $default;

    // Matrix defaults span multiple lines
    $line = `strip $line` + `fgetline $fid`;
    $line = `strip $line` + `fgetline $fid`;
    $line = `strip $line` + `fgetline $fid`;

    // Strip everything ahead of the default
    string $strip1 = `substitute "^.*[Dd]efault value:.*\\[" $line ""`;
    if ( $strip1 == $line ) return $default;

    // Strip the trailing "]" plus anything after it
    string $strip2 = `substitute "\\].*$" $strip1 ""`;
    if ( $strip2 == $strip1 ) return $default;

    string $t[16];
    tokenize $strip2 $t;
    $default = ( "<<"+$t[0 ]+", "+$t[1 ]+", "+$t[2 ]+", "+$t[3 ]+"; "+
                      $t[4 ]+", "+$t[5 ]+", "+$t[6 ]+", "+$t[7 ]+"; "+
                      $t[8 ]+", "+$t[9 ]+", "+$t[10]+", "+$t[11]+"; "+
                      $t[12]+", "+$t[13]+", "+$t[14]+", "+$t[15]+">>" );

    return $default;
}

proc string
getParamDefaultV( int $fid )
{
    string $default = "<<0, 0, 0>>";
    string $line = `fgetline $fid`;

    // First check for "Unknown"
    if ( `match "Unknown" $line` != "" )
        return $default;

    // Strip everything ahead of the default
    string $strip1 = `substitute "^.*[Dd]efault value:.*\\[" $line ""`;
    if ( $strip1 == $line ) return $default;

    // Strip the trailing "]" plus anything after it
    string $strip2 = `substitute "\\].*$" $strip1 ""`;
    if ( $strip2 == $strip1 ) return $default;

    string $tokens[];
    tokenize $strip2 $tokens;
    $default = ( "<<" + $tokens[0] + ", " +
                 $tokens[1] + ", " +
                 $tokens[2] + ">>" );

    return $default;
}

proc string
getParamDefault( int $fid, string $paramType )
{
    string $default = "";

    switch ( $paramType )
    {
    case "string":
        $default = getParamDefaultS( $fid );
        break;
    case "float":
        $default = getParamDefaultF( $fid );
        break;
    case "matrix":
        $default = getParamDefaultM( $fid );
        break;
    case "color":
    case "point":
    case "vector":
    case "normal":
        $default = getParamDefaultV( $fid );
        break;
    default:
        // This should never be reached
        error( "unknown parameter type \"" + $paramType + "\"" );
    }
    
    return $default;
}


//////////////////////////////////////////////////////////////////////////////
//
// Primary global procedure for parsing a prman .slo shader file
//

global proc
liquidSlParseSlo( string $sloFile )
{
    if ( ! `filetest -r $sloFile` )
    {
        error( "shader does not exist: " + $sloFile );
        return;
    }


    //
    // Initialize the global variables
    // used to store all the shader info
    //

    global string $gLiquidSlShaderFile;
    global string $gLiquidSlShaderType;
    global int    $gLiquidSlNumParams;
    global string $gLiquidSlParamNames[];
    global string $gLiquidSlParamTypes[];
    global string $gLiquidSlParamDefaults[];
    global int    $gLiquidSlParamArraySizes[];

    $gLiquidSlShaderFile = $sloFile;
    $gLiquidSlShaderType = "";
    $gLiquidSlNumParams = -1;
    clear( $gLiquidSlParamNames );
    clear( $gLiquidSlParamTypes );
    clear( $gLiquidSlParamDefaults );
    clear( $gLiquidSlParamArraySizes );


    // Strip the extension otherwise sloinfo will barf
    $sloFile = `substitute "\\.slo$" $sloFile ""`;

    // Build and run the sloinfo command
    // TODO: probably won't work under NT
    string $cmd = "sloinfo " + $sloFile;
    int $fid = `popen $cmd "r"`;


    // Get the shader type
    string $shaderType = getShaderType( $fid );
    if ( $shaderType != "surface"       &&
         $shaderType != "displacement"  &&
         $shaderType != "volume"        &&
         $shaderType != "light"            )
    {
        pclose $fid;
        error( "unknown shader type \"" + $shaderType +
               "\": " + $sloFile );
        return;
    }

    // Store the shader type
    $gLiquidSlShaderType = $shaderType;


    //
    // Now for each parameter...
    //

    string $line = `fgetline $fid`;
    int $paramNum = 0;

    while ( ! `feof $fid` )
    {
        // Skip empty lines
        if ( `substitute "^[ \t\r\n]*$" $line ""` == "" )
        {
            $line = `fgetline $fid`;
            continue;
        }

        string $paramName = getParamName( $line );
        if ( $paramName == "" )
        {
            pclose $fid;
            error( "parameter #" + $paramNum +
                   ": cannot parse parameter name" );
            return;
        }

        string $paramType = getParamType( $line );
        if ( $paramType == "" )
        {
            pclose $fid;
            error( "parameter " + $paramNum +
                   ": cannot parse parameter type" );
            return;
        }

        int $paramArraySize = getParamArraySize( $line );

        string $paramDefault = getParamDefault( $fid, $paramType );

        if ( $paramArraySize > 0 )
        {
            int $i = 1;
            for ( ; $i < $paramArraySize; $i++ )
            {
                string $this = getParamDefault( $fid, $paramType );
                $paramDefault += ", " + $this;
            }
            $paramDefault = "{" + $paramDefault + "}";
        }


        // Store the results for this parameter
        $gLiquidSlParamNames[ $paramNum ] = $paramName;
        $gLiquidSlParamTypes[ $paramNum ] = $paramType;
        $gLiquidSlParamDefaults[ $paramNum ] = $paramDefault;
        $gLiquidSlParamArraySizes[ $paramNum ] = $paramArraySize;

        $line = `fgetline $fid`;
        $paramNum += 1;
    }

    // Store the total number of shader parameters
    $gLiquidSlNumParams = $paramNum;

    pclose $fid;
}
