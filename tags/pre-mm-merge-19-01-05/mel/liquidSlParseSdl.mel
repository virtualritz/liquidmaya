//
//
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the 
// "License"); you may not use this file except in compliance with the License. You may 
// obtain a copy of the License at http://www.mozilla.org/MPL/ 
// 
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT 
// WARRANTY OF ANY KIND, either express or implied. See the License for the specific 
// language governing rights and limitations under the License. 
//
// The Original Code is the Liquid Rendering Toolkit. 
// 
// The Initial Developer of the Original Code is Colin Doncaster. Portions created by 
// Colin Doncaster are Copyright (C) 2002. All Rights Reserved. 
// 
// Contributor(s): Berj Bannayan. 
//
// 
// The RenderMan (R) Interface Procedures and Protocol are:
// Copyright 1988, 1989, Pixar
// All Rights Reserved
//
//
// RenderMan (R) is a registered trademark of Pixar
//
//  Creation Date:    July 8, 2003
//
//  Procedure Name:
//      liquidSlParseSdl
//
//  Description:
//      Procedure called by liquidSlSetShader() to parse
//      a 3delight .sdl shader file.  All parsed information
//      is stored in the following global variables later
//      used by the various liquidSl* routines:
//
//          global string $gLiquidSlShaderType;
//          global int    $gLiquidSlNumParams;
//          global string $gLiquidSlParamNames[];
//          global string $gLiquidSlParamTypes[];
//          global string $gLiquidSlParamDefaults[];
//          global int    $gLiquidSlParamArraySizes[];
//
//


//////////////////////////////////////////////////////////////////////////////
//
// Local helper procedures
//

proc string
getShaderType( int $fid )
{
    string $type = "";

    // The first word on the first non-empty
    // line is the shader type.

    string $tokens[];
    string $line = `fgetline $fid`;
    while ( ! `feof $fid` )
    {
        clear( $tokens );
        tokenize $line $tokens;
        $type = $tokens[0];
        if ( $type != "" ) break;
        $line = `fgetline $fid`;
    }

    return $type;
}

proc string
getParamName( string $line )
{
    string $strip = `substitute "^[^\"]*\"" $line ""`;
    if ( $strip == $line ) return "";

    string $name = `substitute "\".*$" $strip ""`;
    if ( $name == $strip ) return "";

    return $name;
}

proc string
getParamType( string $line )
{
    string $prefix = "\"[^\"]*[uniformvaryg]+ *";

    if      ( `match ($prefix+"string") $line` != "" ) return "string";
    else if ( `match ($prefix+"float")  $line` != "" ) return "float";
    else if ( `match ($prefix+"color")  $line` != "" ) return "color";
    else if ( `match ($prefix+"point")  $line` != "" ) return "point";
    else if ( `match ($prefix+"vector") $line` != "" ) return "vector";
    else if ( `match ($prefix+"normal") $line` != "" ) return "normal";
    else if ( `match ($prefix+"matrix") $line` != "" ) return "matrix";

    return "";
}

proc int
getParamArraySize( string $line )
{
    string $strip = `substitute "^.*[a-z]\\[" $line ""`;
    if ( $strip == $line ) return 0;

    string $sizeStr = `substitute "\\].*$" $strip ""`;
    if ( $sizeStr == $strip ) return 0;

    int $sizeInt = $sizeStr;
    return $sizeInt;
}

proc string
getParamDefaultF( int $fid, int $arraySize )
{
    string $default = "0.0";
    string $line = strip( `fgetline $fid` );

    // Strip everything ahead of the default
    string $strip = `substitute "^.*Default value: *" $line ""`;
    if ( $strip != $line )
    {
        $default = $strip;
    }
    else if ( $arraySize > 0 )
    {
        // Build an array of zeros
        $default = "{0";
        int $i = 1;
        for ( ; $i < $arraySize; $i++ )
            $default += ", 0";
        $default += "}";
    }

    return $default;
}

proc string
getParamDefaultS( int $fid, int $arraySize )
{
    string $default = "";

    // Use an array of size 1 as the array default.
    // This will work even if the array is supposed
    // to be larger.
    if ( $arraySize > 0 ) $default = "{\"\"}";

    string $line = strip( `fgetline $fid` );

    // Strip everything ahead of the default
    // (leaving the double-quotes around it)
    string $strip = `substitute "^.*Default value: *" $line ""`;
    if ( $strip != $line )
        $default = $strip;

    return $default;
}

proc string
getParamDefaultM( int $fid, int $arraySize )
{
    // Array matrices not supported yet,
    if ( $arraySize > 0 ) return "";

    string $default = ( "<<0, 0, 0, 0; " +
                        "0, 0, 0, 0;" +
                        "0, 0, 0, 0;" +
                        "0, 0, 0, 0>>" );

    string $line = `fgetline $fid`;

    // Strip everything ahead of the default
    string $strip1 = `substitute "^.*Default value:.*\\[" $line ""`;
    if ( $strip1 == $line ) return $default;

    // Strip the trailing "]" plus anything after it
    string $strip2 = `substitute "\\].*$" $strip1 ""`;
    if ( $strip2 == $strip1 ) return $default;

    string $t[16];
    tokenize $strip2 $t;
    $default = ( "<<"+$t[0 ]+", "+$t[1 ]+", "+$t[2 ]+", "+$t[3 ]+"; "+
                      $t[4 ]+", "+$t[5 ]+", "+$t[6 ]+", "+$t[7 ]+"; "+
                      $t[8 ]+", "+$t[9 ]+", "+$t[10]+", "+$t[11]+"; "+
                      $t[12]+", "+$t[13]+", "+$t[14]+", "+$t[15]+">>" );

    return $default;
}

proc string
getParamDefaultV( int $fid, int $arraySize )
{
    string $default = "";
    string $line = `fgetline $fid`;

    if ( $arraySize > 0 )
    {
        // Strip everything up to and including the leading '{'
        string $strip1 = `substitute "^.*Default value:.*\\{" $line ""`;

        // Strip the trailing "}" plus anything after it
        string $strip2 = `substitute "\\}.*$" $strip1 ""`;

        string $tokens[];
        tokenize $strip2 "[], " $tokens;
        if ( size($tokens) == $arraySize*3 )
        {
            $default = ( "{<<" + $tokens[0] + ", " +
                                 $tokens[1] + ", " +
                                 $tokens[2] + ">>" );
            int $i = 3;
            for ( ; $i < size($tokens); $i += 3 )
            {
                $default += ( ", <<" + $tokens[$i  ] + ", " +
                                       $tokens[$i+1] + ", " +
                                       $tokens[$i+2] + ">>" );
            }
            $default += "}";
        }
        else
        {
            $default = "{<<0,0,0>>";
            int $i = 3;
            for ( ; $i < size($tokens); $i += 3 )
            {
                $default += ", <<0,0,0>>";
            }
            $default += "}";
        }
    }
    else  // not an array
    {
        $default = "<<0, 0, 0>>";

        // Strip everything ahead of the default
        string $strip1 = `substitute "^.*Default value:.*\\[" $line ""`;
        if ( $strip1 == $line ) return $default;

        // Strip the trailing "]" plus anything after it
        string $strip2 = `substitute "\\].*$" $strip1 ""`;
        if ( $strip2 == $strip1 ) return $default;

        string $tokens[];
        tokenize $strip2 $tokens;
        $default = ( "<<" + $tokens[0] + ", " +
                     $tokens[1] + ", " +
                     $tokens[2] + ">>" );
    }

    return $default;
}

proc string
getParamDefault( int $fid, string $paramType, int $arraySize )
{
    string $default = "";

    switch ( $paramType )
    {
    case "string":
        $default = getParamDefaultS( $fid, $arraySize );
        break;
    case "float":
        $default = getParamDefaultF( $fid, $arraySize );
        break;
    case "matrix":
        $default = getParamDefaultM( $fid, $arraySize );
        break;
    case "color":
    case "point":
    case "vector":
    case "normal":
        $default = getParamDefaultV( $fid, $arraySize );
        break;
    default:
        // This should never be reached
        error( "unknown parameter type \"" + $paramType + "\"" );
    }
    
    return $default;
}


//////////////////////////////////////////////////////////////////////////////
//
// Primary global procedure for parsing a 3delight .sdl shader file
//

global proc
liquidSlParseSdl( string $sdlFile )
{
    if ( ! `filetest -r $sdlFile` )
    {
        error( "shader does not exist: " + $sdlFile );
        return;
    }


    //
    // Initialize the global variables
    // used to store all the shader info
    //

    global string $gLiquidSlShaderFile;
    global string $gLiquidSlShaderType;
    global int    $gLiquidSlNumParams;
    global string $gLiquidSlParamNames[];
    global string $gLiquidSlParamTypes[];
    global string $gLiquidSlParamDefaults[];
    global int    $gLiquidSlParamArraySizes[];

    $gLiquidSlShaderFile = $sdlFile;
    $gLiquidSlShaderType = "";
    $gLiquidSlNumParams = -1;
    clear( $gLiquidSlParamNames );
    clear( $gLiquidSlParamTypes );
    clear( $gLiquidSlParamDefaults );
    clear( $gLiquidSlParamArraySizes );

    // Build and run the shaderinfo command
    // TODO: probably won't work under NT
    string $cmd = "shaderinfo " + $sdlFile;
    int $fid = `popen $cmd "r"`;


    // Get the shader type
    string $shaderType = getShaderType( $fid );
    if ( $shaderType != "surface"       &&
         $shaderType != "displacement"  &&
         $shaderType != "volume"        &&
         $shaderType != "light"            )
    {
        pclose $fid;
        error( "unknown shader type \"" + $shaderType +
               "\": " + $sdlFile );
        return;
    }

    // Store the shader type
    $gLiquidSlShaderType = $shaderType;


    //
    // Now for each parameter...
    //

    string $line = `fgetline $fid`;
    int $paramNum = 0;

    while ( ! `feof $fid` )
    {
        // Skip empty lines
        if ( `substitute "^[ \t\r\n]*$" $line ""` == "" )
        {
            $line = `fgetline $fid`;
            continue;
        }

        string $paramName = getParamName( $line );
        if ( $paramName == "" )
        {
            pclose $fid;
            error( "parameter #" + $paramNum +
                   ": cannot parse parameter name" );
            return;
        }

        string $paramType = getParamType( $line );
        if ( $paramType == "" )
        {
            pclose $fid;
            error( "parameter " + $paramNum +
                   ": cannot parse parameter type" );
            return;
        }

        int $paramArraySize = getParamArraySize( $line );

        string $paramDefault = getParamDefault( $fid, $paramType,
                                                $paramArraySize );

        // Store the results for this parameter
        $gLiquidSlParamNames[ $paramNum ] = $paramName;
        $gLiquidSlParamTypes[ $paramNum ] = $paramType;
        $gLiquidSlParamDefaults[ $paramNum ] = $paramDefault;
        $gLiquidSlParamArraySizes[ $paramNum ] = $paramArraySize;

        $line = `fgetline $fid`;
        $paramNum += 1;
    }

    // Store the total number of shader parameters
    $gLiquidSlNumParams = $paramNum;

    pclose $fid;
}
