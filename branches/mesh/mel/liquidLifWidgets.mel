//
//
// The contents of this file are subject to the Mozilla Public License Version 1.1 (the
// "License"); you may not use this file except in compliance with the License. You may
// obtain a copy of the License at http://www.mozilla.org/MPL/
//
// Software distributed under the License is distributed on an "AS IS" basis, WITHOUT
// WARRANTY OF ANY KIND, either express or implied. See the License for the specific
// language governing rights and limitations under the License.
//
// The Original Code is the Liquid Rendering Toolkit.
//
// The Initial Developer of the Original Code is Colin Doncaster. Portions created by
// Colin Doncaster are Copyright (C) 2002. All Rights Reserved.
//
// Contributor(s): Philippe Leprince.
//
//
// The RenderMan (R) Interface Procedures and Protocol are:
// Copyright 1988, 1989, Pixar
// All Rights Reserved
//
//
// RenderMan (R) is a registered trademark of Pixar
//
//  Creation Date:    July 8, 2003
//
//  Procedure Name:
//      liquidLifWidgets
//
//  $Revision: 1.9 $
//

proc string paramName( string $name, int $index )
{
  return ( $index < 0 )? $name : ( $name + "[" + $index + "]" );
}

proc string controlName( string $name )
{
  global string $gLiquid_currentAEShader;
  
  string  $tokens[] = stringToStringArray(($gLiquid_currentAEShader+"_"+$name), ":[].\t -");
  return stringArrayToString($tokens, "_") + "_LIF";
}

// Top copy the value between two plugs of same type
proc copyPlug ( string $srcPlug, string $dstPlug, int $connect )
{
  string  $srcType  = `getAttr -type $srcPlug`;
  string  $dstType  = `getAttr -type $dstPlug`;
  
  if ( $srcType == $dstType ) 
  {
    string  $conn[] = {};
    if ( $connect && size($conn = `listConnections -s true -d false -p true $srcPlug`) ) 
    {
      connectAttr -f $conn[0] $dstPlug;
    } 
    else 
    {
      if ( size($conn = `listConnections -s true -d false -p true $dstPlug`) ) 
      {
        disconnectAttr $conn[0] $dstPlug;
      }
      switch ( $dstType ) 
      {
        case "int" :
        case "byte" :
        case "short" :
        case "long" :
        case "bool" :
        case "char" :
        case "enum" :
        case "float" :
        case "double" :
        case "doubleAngle" :
        case "doubleLinear" :
        case "time" :
          setAttr $dstPlug `getAttr $srcPlug`;
          break;
        case "double3" :
        case "float3" :
          float $v[] = `getAttr $srcPlug`;
          setAttr $dstPlug $v[0] $v[1] $v[2];
          break;
        case "matrix" :
          float $m[] = `getAttr $srcPlug`;
          setAttr -type "matrix" $dstPlug $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15];
          break;
        case "string" :
        default :
          setAttr -type $dstType $dstPlug `getAttr $srcPlug`;
          break;
      }
    }
  } 
  else 
    error ("[liquidLifWidgets.copyPlug] can not copy from "+$srcPlug+" ("+$srcType+") to "+$dstPlug+" ("+$srcType+")");
}


/*******************************************************************
  Single parameter widgets, by widget and parameter type
********************************************************************/


/********************************************************************
  Selectors (for all types)
********************************************************************/

global proc liquidAE_Lif_selectorPlugChanged( string $ctlName, string $paramType, string $plug )
{
  string  $defaultValue = "";
  // string $type     = `getAttr -type $plug`;
  switch ( $paramType) 
  {
    case "float" :
      float $f = `getAttr $plug`;
      $currentValue = string($f);
      break;
    case "point" :
    case "vector" :
    case "normal" :
    case "color" :                  
      vector $v = `getAttr $plug`;
      $currentValue = string($v);
      break;        
    case "matrix":
      float $fm[] = `getAttr $plug`;
      $currentValue = liquidSlfloatMatrixToString($fm);
      break;
    case "string" :
    case "shader" :
      $currentValue = `getAttr $plug`;
      break;          
    default :
      warning ("[liquidAE_Lif_selectorPlugChanged] attribute type \""+$paramType+"\" not handled yet !");
  } 

  string  $items[]  = `optionMenuGrp -q -ill $ctlName`; 
  string  $data;
  int   $ni     = size($items);
  int   $index    = 0;
  
  for ( $i = 0; $i < $ni; $i++ ) 
  {
    $data     = `menuItem -q -ann $items[$i]`;
    if ( liquidSlTypedStringEquivalent($paramType, $currentValue, $data) ) 
    {
      $index    = $i+1;
      break;
    }   
  }
  if ( $index > 0 ) 
    optionMenuGrp -e -sl $index $ctlName; 
}

// Modified to accomodate selector for non int parameters
global proc string liquidAE_Lif_selector( string $paramName, string $paramType, string $attr, string $label, string $range[], string  $description, int $state )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  ltrace ("\t[liquidAE_Lif_selector] for " + $paramType + " " + $paramName + " " + $attr + " " + $label
           + " ["+stringArrayToString($range, " ") + "] state " + $state + " " + $description );

  string $plug = ( $gLiquid_currentAENode + "." + $attr );
  string $mayaType = `getAttr -typ $plug`;
  string $ctlName = controlName( $paramName);
  int $visible = liquidLifVisible($state);
  int $enable = liquidLifEnable($state);
      
  int $numSize = size( $range );
  int $li, $di;
  string $labels[];
  string $data[];
  int $nl = 0;
  int $isIntEnum = 1;
  for ( $k = 0; $k < $numSize; $k = $k + 2 ) 
  {
    $li = $k;
    $di = $k + 1;
    $labels[$nl] = $range[$li];
    if ( ($di >= $numSize) || ($range[$di] == "") ) 
    {
      warning ("[liquidAE_Lif_selector] missing data for label "+$labels[$nl]+" on index "+$k+" of range: ["+stringArrayToString($range, " ")+"]");
      $data[$nl] = "0";
    } 
    else 
    {
      $data[$nl] = $range[$di];
      if (!liquidSlValidIntString($data[$nl])) 
      {
        $isIntEnum = 0;
      }
        }
    $nl += 1;
  }
  // Checking that data conforms with attribute type
  if ( !liquidSlConformStrings ($paramType, $data) ) 
  {
    warning ("[liquidAE_Lif_selector] some of the range data is not correct for a "+$paramType+" attribute: ["+stringArrayToString($range, " ")+"]");
  }
  int $method;
  if ( ($paramType == "float") && ($isIntEnum == 1) ) 
  {
    ltrace ("\t\t[liquidAE_Lif_selector] using int enum method for values: "+stringArrayToString($data, "|"));
    $method = 0;
  } 
  else 
  {
    ltrace ("\t\t[liquidAE_Lif_selector] using callback method for values: "+stringArrayToString($data, "|"));  
    $method = 1;
  }     
  if ( !`control -q -ex $ctlName` ) 
  {  
    string $menu = `optionMenuGrp -parent $gLiquid_currentAEParent -label $label $ctlName`;
      
    if ( $method == 0 ) {
      for ( $k=0; $k<$nl; $k+=1) 
      {
        menuItem -l $labels[$k] -data (float($data[$k]));
      }
    } 
    else 
    {
      for ( $k = 0 ; $k < $nl ; $k += 1) 
      {
        menuItem -l $labels[$k] -data $k -ann $data[$k]; 
      }
      // ScriptJob to keep the menu up to date with the attribute
      scriptJob -p $ctlName -alc -ac $plug ("liquidAE_Lif_selectorPlugChanged( \""+$ctlName+"\", \""+$paramType+"\", \""+$plug+"\")");           
    }
    optionMenuGrp -e -ann $description -visible $visible -enable $enable $ctlName;
  } 
  else 
  {
    optionMenuGrp -e -ann $description $ctlName;  
  }     
  // Callbacks and connect to attribute must be redone as node name can have changed even if layout is not rebuilt
  // (you can have several instances of the same shader sharing the same layout)
  // Enum like for ints on float params, use a callback all other cases
  if ( $method == 0 ) 
  {
    connectControl -index 2 $ctlName $plug;
  } 
  else 
  {
    // Restore the widget state to the current plug value
    string $currentValue = "";
    switch ( $paramType ) 
    {
      case "float" :
        float $f = `getAttr $plug`;
        $currentValue = string($f);
        break;
      case "point" :
      case "vector" :
      case "normal" :
      case "color" :                  
        vector $v = `getAttr $plug`;
        $currentValue = string($v);
        break;        
      case "matrix":
        float $fm[] = `getAttr $plug`;
        $currentValue = liquidSlfloatMatrixToString($fm);
        break;
      case "string" :
      case "shader" :
        $currentValue = `getAttr $plug`;
        break;        
      default :
        warning ("[liquidAE_LifParameter] \""+$paramType+"\" not handled yet !");
    }
    int $currentIndex = 0;   
    string $cmd = "switch(\"#1\") {\n";
    for ( $k = 0 ; $k < $nl ; $k += 1) 
    {
      $cmd += "case \""+$labels[$k]+"\": evalEcho(\"setAttr ";
      if ( $mayaType == "string" ) 
      {
        $cmd += "-type \\\"string\\\" "+$plug+" \\\""+$data[$k]+"\\\"\"); break;\n";
      } 
      else 
      {
        $cmd += $plug+" "+$data[$k]+"\"); break;\n";
      }
      if ( ($currentIndex == 0) && (liquidSlTypedStringEquivalent($paramType, $currentValue, $data[$k])) ) 
      {
        $currentIndex = $k+1;
      }
    }
    $cmd += "default: break;\n}\n";
    // Restore the widget state to the current plug value
    if ($currentIndex != 0) 
    {
      optionMenuGrp -e -sl $currentIndex $ctlName; 
    }
    optionMenuGrp -e -cc $cmd $ctlName;
  }

  return $ctlName;
}


/********************************************************************
  Field (several types)
********************************************************************/

global proc string liquidAE_Lif_field( string $paramName, string $paramType, string $attr, string $label, string $range[], string $description, int $state )
{
  ltrace ("\t[liquidAE_Lif_field] " + $paramName + ", type: " + $paramType + ", attr: " + $attr + ", label: " + $label
          + ", range: [" + stringArrayToString($range, " ") + "], state: " + $state + ", desc: " + $description);

  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAEShader;

  // !!! temporary solution for compatibility with previose versions
  if ( $attr == -1 ) $attr = $paramName;
  
  string $plug = ($gLiquid_currentAENode+"."+$attr);
  string $mayaType = `getAttr -typ $plug`;
  string $ctlName = controlName( $paramName);
  int $visible = liquidLifVisible($state);
  int $enable = liquidLifEnable($state);

  if ( !`control -q -ex ($ctlName)` ) 
  {
    attrFieldGrp  -p $gLiquid_currentAEParent
                  -label $label
                  // -cc ( "liquidParamAU " + $gLiquid_currentAENode )
                  -at $plug
                  -hmb true
                  -visible $visible -enable $enable 
                  $ctlName;                   
  } 
  else 
  {
    attrFieldGrp -e -hmb true -ann $description $ctlName;
  }
  
  return $ctlName;
}

/********************************************************************
  Floats
********************************************************************/
  
global proc string liquidAE_LifFloat_field( string $paramName, string $attr, string $label, string $range[], string $description, int $state )
{
  ltrace ("\t[liquidAE_LifFloat_field] " + $paramName + ", attr: " + $attr + ", label: " + $label
          + ", range: [" + stringArrayToString($range, " ") + "], state: " + $state + ", desc: " + $description);

  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAEShader;

  // !!! temporary solution for compatibility with previose versions
  if ( $attr == -1 ) $attr = $paramName;
  
  string $plug = ( $gLiquid_currentAENode + "." + $attr );
  string $mayaType = `getAttr -typ $plug`;
  string $ctlName = controlName( $paramName);
  int $visible = liquidLifVisible($state);
  int $enable = liquidLifEnable($state);

  if ( !`control -q -ex ($ctlName)` ) 
  {
    floatFieldGrp -p $gLiquid_currentAEParent
                      -label $label
                      // -cc ( "liquidParamAU " + $gLiquid_currentAENode )
                      -visible $visible -enable $enable 
                      $ctlName;                 
  } 
  else 
  {
    floatFieldGrp -e -ann $description $ctlName;
  }

  connectControl -index 2 $ctlName $plug;
  
  return $ctlName;
}       

 //  TODO : -step support ? Different field and slide min / max ?

global proc string liquidAE_LifFloat_slider( string $paramName, string $attr, string $label, string $range[], string $description, int $state )
{
  ltrace ( "[liquidAE_LifFloat_slider] param: " + $paramName + ", attr: " + $attr + ", label: " + $label
            + ", range: [" + stringArrayToString($range, " ") + "], state: " + $state + ", desc: " + $description);
  
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAEShader;

  // !!! temporary solution for compatibility with previose versions
  if ( $attr == -1 ) $attr = $paramName;
  
  string $plug = ( $gLiquid_currentAENode + "." + $attr );
  string $mayaType = `getAttr -typ $plug`;
  string $ctlName = controlName( $paramName );
  int $visible = liquidLifVisible( $state );
  int $enable = liquidLifEnable( $state );

  float $min, $max, $slmin, $slmax;
  if ( size($range) == 2 ) 
  {
    $min    = $range[0];
    $max    = $range[1];
    $slmin  = $range[0];
    $slmax  = $range[1];
  }
  if ( $min == $max ) 
  {
    $min    = -100000000;
    $max    =  100000000;
    float $val = `getAttr $plug`;
    $slmin  =  ( $val > 0 ) ? 0 : $val * 2;
    $slmax  =  ( $val == 0 ) ? 1 : ( $val > 0 ) ? $val * 2 : 0;
  }

  if ( !`control -q -ex ($ctlName)` ) 
  {
    // print ( "[liquidAE_LifFloat_slider] create control " + $ctlName + "\n" );  
    attrFieldSliderGrp  -parent $gLiquid_currentAEParent
                        -label  $label
                        -ann    $description
                        -fieldMinValue $min -fieldMaxValue  $max
                        -minValue $slmin  -maxValue  $slmax
                        -sliderMinValue $slmin  -sliderMaxValue $slmax
                        -at $plug
                        // -cc ( "liquidParamAU " + $gLiquid_currentAENode )
                        -visible $visible   -enable $enable             
                        -hideMapButton true
                        $ctlName;
                          
  } 
  else 
  {
    // print ( "[liquidAE_LifFloat_slider] edit control " + $ctlName + "\n" );  
    attrFieldSliderGrp  -e
                        -at $plug
                        -fieldMinValue $min -fieldMaxValue  $max
                        -minValue $slmin    -maxValue  $slmax
                        -sliderMinValue $slmin  -sliderMaxValue $slmax
                        $ctlName;
  }
  
  return $ctlName;
}


global proc string liquidAE_LifFloat_bool( string $paramName, string $attr, string $label, string $range[], string $description, int $state )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;

  ltrace ("\t[liquidAE_LifFloat_bool] " + $paramName + " " + $attr + " " + $label + " state " + $state + " " + $description );

  // !!! temporary solution for compatibility with previose versions
  if ( $attr == -1 ) $attr = $paramName;
  
  string $plug = ( $gLiquid_currentAENode + "." + $attr );
  string $mayaType = `getAttr -typ $plug`;
  string $ctlName = controlName( $paramName);
  int $visible = liquidLifVisible($state);
  int $enable = liquidLifEnable($state);

  if ( !`control -q -ex $ctlName` ) 
  {
    checkBoxGrp -parent $gLiquid_currentAEParent
                -label $label
                -ann $description
                -visible $visible -enable $enable
                // -cc ( "liquidParamAU " + $gLiquid_currentAENode )
                $ctlName;
  } 
  else 
  {
    checkBoxGrp -e -ann $description $ctlName;
  }

  connectControl -index 2 $ctlName $plug;
  
  return $ctlName;
}

// With support for a single float array, called from liquidAE_LifParameter
global proc string liquidAE_LifFloat( string $paramName, string $attr, string $subtype, string $label, string $range[], string $description, int $state )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  string      $resultCtl;
  
  ltrace ("[liquidAE_LifFloat] on "+$gLiquid_currentAENode+" for "+$paramName+", UI type "+$subtype
      + ", label "+$label+",range ["+stringArrayToString($range, " ")+"], state "+$state+", desc "+$description);
          
  string  $subtypes[] = stringToStringArray( $subtype, "|");
  string  $stype    = $subtypes[0];

  // save UI parent
  string  $saveParent = $gLiquid_currentAEParent;
  setParent $gLiquid_currentAEParent;
    
  switch ( $stype ) 
  {
    case "selector":
      $resultCtl = liquidAE_Lif_selector( $paramName, "float", $attr, $label, $range, $description, $state );
      break;
    case "checkbox":
    case "bool":
      $resultCtl = liquidAE_LifFloat_bool( $paramName, $attr, $label, $range, $description, $state );
      break; 
    case "field": 
      $resultCtl = liquidAE_LifFloat_field( $paramName, $attr, $label, $range, $description, $state );        
      break;                  
    case "slider":        
    default :
      $resultCtl = liquidAE_LifFloat_slider( $paramName, $attr, $label, $range, $description, $state );
      break;
  }

  // restore saved parent
  $gLiquid_currentAEParent = $saveParent;
  setParent $gLiquid_currentAEParent;
    
  ltrace ("[liquidAE_LifFloat] done!");

  return $resultCtl;
}

/********************************************************************
  Colors
********************************************************************/

global proc string liquidAE_LifColor_slider( string $paramName, string $attr, string $label, string $range[], string $description, int $state )
{
  ltrace ("\t[liquidAE_LifColor_slider] param: " + $paramName + ", attr: " + $attr + ", label: " + $label 
          + ", range: [" + stringArrayToString($range, " ") + "], state: " + $state + ", desc: " + $description );

  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAEShader;

  // !!! temporary solution for compatibility with previose versions
  if ( $attr == -1 ) $attr = $paramName;
  
  string $plug = ( $gLiquid_currentAENode + "." + $attr );
  // string $mayaType = `getAttr -typ $plug`;
  string $ctlName = controlName( $paramName );
  int $visible = liquidLifVisible( $state );
  int $enable = liquidLifEnable( $state );

  if ( !`control -q -ex ($ctlName)` ) 
  {
    attrColorSliderGrp  -parent $gLiquid_currentAEParent
                        -label  $label
                        -ann    $description
                        -at     $plug
                        -showButton false
                        // -cc ( "liquidParamAU " + $gLiquid_currentAENode )
                        -visible $visible   
                        -enable $enable
                        $ctlName;
  } 
  else 
  {
    attrColorSliderGrp  -e
              -sb false
              -at $plug
              -ann $description
              $ctlName;
  }

  
  return $ctlName;
}

global proc string liquidAE_LifColor( string $paramName, string $attr, string $subtype, string $label, string $range[], string $description, int $state )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  string      $resultCtl;
  
  ltrace ("[liquidAE_LifColor] on "+$gLiquid_currentAENode+" for "+$paramName+", UI type "+$subtype
      + ", label "+$label+",range ["+stringArrayToString($range, " ")+"], state "+$state+", desc "+$description);
          
  string  $subtypes[] = stringToStringArray( $subtype, "|");
  string  $stype    = $subtypes[0];

  // save UI parent
  string  $saveParent = $gLiquid_currentAEParent;
  setParent $gLiquid_currentAEParent;
    
  switch ( $stype ) 
  {      
    case "selector":
      $resultCtl = liquidAE_Lif_selector( $paramName, "color", $attr, $label, $range, $description, $state );
      break;  
    case "field":
      $resultCtl = liquidAE_Lif_field( $paramName, "color", $attr, $label, $range, $description, $state );
      break;                  
    case "slider":        
    default :
      $resultCtl = liquidAE_LifColor_slider( $paramName, $attr, $label, $range, $description, $state );
      break;
  }

  // restore saved parent
  $gLiquid_currentAEParent = $saveParent;
  setParent $gLiquid_currentAEParent;
    
  ltrace ("[liquidAE_LifColor] done!");

  return $resultCtl;
}



/********************************************************************
  Vectors
********************************************************************/


global proc string liquidAE_LifVector( string $paramName, string $attr, string $subtype, string $label, string $range[], string $description, int $state )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  string      $resultCtl;
  
  ltrace ("[liquidAE_LifVector] on "+$gLiquid_currentAENode+" for "+$paramName+", UI type "+$subtype
      + ", label "+$label+",range ["+stringArrayToString($range, " ")+"], state "+$state+", desc "+$description);
          
  string  $subtypes[] = stringToStringArray( $subtype, "|");
  string  $stype    = $subtypes[0];

  // save UI parent
  string  $saveParent = $gLiquid_currentAEParent;
  setParent $gLiquid_currentAEParent;
    
  switch ( $stype ) 
  {      
    case "selector":
      $resultCtl = liquidAE_Lif_selector( $paramName, "color", $attr, $label, $range, $description, $state );
      break;                
    case "field":       
    default :
      $resultCtl = liquidAE_Lif_field( $paramName, "vector", $attr, $label, $range, $description, $state );
      break;
  }

  // restore saved parent
  $gLiquid_currentAEParent = $saveParent;
  setParent $gLiquid_currentAEParent;
    
  ltrace ("[liquidAE_LifVector] done!");

  return $resultCtl;
}

/********************************************************************
  Matrix
********************************************************************/

global proc liquidAE_LifMatrix_update(string $controlName, string $plugName)
{
  string $floatFieldGrps[] = `columnLayout -q -ca $controlName`;
  float $val0[] = `floatFieldGrp -q -value $floatFieldGrps[0]`;
  float $val1[] = `floatFieldGrp -q -value $floatFieldGrps[1]`;
  float $val2[] = `floatFieldGrp -q -value $floatFieldGrps[2]`;
  float $val3[] = `floatFieldGrp -q -value $floatFieldGrps[3]`;
  
  setAttr $plugName -type "matrix"  $val0[0] $val0[1] $val0[2] $val0[3]
                    $val1[0] $val1[1] $val1[2] $val1[3]
                    $val2[0] $val2[1] $val2[2] $val2[3]
                    $val3[0] $val3[1] $val3[2] $val3[3] ;
}



global proc string liquidAE_LifMatrix_field( string $paramName, string $attr, string $label, string $range[], string $description, int $state )
{
  ltrace ("\t[liquidAE_LifMatrix_field] param: "+$paramName+", attr: "+$attr+", label: "+$label+", range: ["+stringArrayToString($range, " ")+"], state: "+$state+", desc: "+$description);

  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAEShader;

  string  $plug   = ($gLiquid_currentAENode+"."+$attr);
  string  $ctlName  = controlName( $paramName);
  int   $visible  = liquidLifVisible($state);
  int   $enable   = liquidLifEnable($state);

  //  Is this attr multi?
  int   $isMulti  = (size(match("[", $attr)) > 0);
  if ( !`control -q -ex ($ctlName)` ) 
  {
    if ( $isMulti ) 
    {
      setUITemplate -pst attributeEditorMatrixMultiTemplate;
    } 
    else 
    {
      setUITemplate -pst attributeEditorMatrixTemplate; 
    }
    columnLayout  -p $gLiquid_currentAEParent
            -visible $visible -enable $enable
            -adj true $ctlName;   
    floatFieldGrp -label $label -ann $description -nf 4;
    floatFieldGrp         -ann $description -nf 4;
    floatFieldGrp         -ann $description -nf 4;
    floatFieldGrp         -ann $description -nf 4;
        
    setUITemplate -ppt;
    setParent   $gLiquid_currentAEParent;
  }
  
  // string $cmd        = "liquidAE_LifMatrix_update(\"" + $ctlNamePath + "\",\"" + $plug + "\")";
  string  $cmd        = "liquidAE_LifMatrix_update(\"" + $ctlName + "\",\"" + $plug + "\")";
  // string $floatFieldGrps[] = `columnLayout -q -ca $ctlNamePath`;
  string  $floatFieldGrps[] = `columnLayout -q -ca $ctlName`; 
  float $val[]        = `getAttr $plug`;          
  floatFieldGrp   -edit -v1 $val[ 0] -v2 $val[ 1] -v3 $val[ 2] -v4 $val[ 3] -cc $cmd -ann $description $floatFieldGrps[0];
  floatFieldGrp   -edit -v1 $val[ 4] -v2 $val[ 5] -v3 $val[ 6] -v4 $val[ 7] -cc $cmd -ann $description $floatFieldGrps[1];
  floatFieldGrp   -edit -v1 $val[ 8] -v2 $val[ 9] -v3 $val[10] -v4 $val[11] -cc $cmd -ann $description $floatFieldGrps[2];
  floatFieldGrp   -edit -v1 $val[12] -v2 $val[13] -v3 $val[14] -v4 $val[15] -cc $cmd -ann $description $floatFieldGrps[3];
    
  return $ctlName;
}

global proc string liquidAE_LifMatrix( string $paramName, string $attr, string $subtype, string $label, string $range[], string $description, int $state )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  string      $resultCtl;
  
  ltrace ("[liquidAE_LifMatrix] on "+$gLiquid_currentAENode+" for "+$paramName+", UI type "+$subtype
      + ", label "+$label+",range ["+stringArrayToString($range, " ")+"], state "+$state+", desc "+$description);
          
  string  $subtypes[] = stringToStringArray( $subtype, "|");
  string  $stype    = $subtypes[0];

  // save UI parent
  string  $saveParent = $gLiquid_currentAEParent;
  setParent $gLiquid_currentAEParent;
    
  switch ( $stype ) 
  {      
    case "selector":
      $resultCtl = liquidAE_Lif_selector( $paramName, "matrix", $attr, $label, $range, $description, $state );
      break;                
    case "field":       
    default :
      $resultCtl = liquidAE_LifMatrix_field( $paramName, $attr, $label, $range, $description, $state );
      break;
  }

  // restore saved parent
  $gLiquid_currentAEParent = $saveParent;
  setParent $gLiquid_currentAEParent;
    
  ltrace ("[liquidAE_LifMatrix] done!");

  return $resultCtl;
}

/********************************************************************
  Strings
********************************************************************/


global proc string liquidAE_LifString_browser( string $paramName, string $attr, string $subtype, string $label, string $range[], string $description, int $state )
{
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAEShader;

  ltrace ("\t[liquidAE_LifString_browser] param: "+$paramName+", attr: "+$attr+", subtype:"+$subtype+", label: "+$label+", range: ["+stringArrayToString($range, " ")+"], state: "+$state+", desc: "+$description);

  string  $plug     = ($gLiquid_currentAENode+"."+$attr);
  // string $mayaType = `getAttr -typ $plug`;
  string  $ctlName    = controlName( $paramName);
  int   $visible    = liquidLifVisible($state);
  int   $enable     = liquidLifEnable($state);

  string  $myFileCommand  = ( "liquidChangeTextFileAttr " + $gLiquid_currentAENode + " " + $attr + " " + $ctlName );
  string  $bttnImage    = "";
  
  switch ( $subtype ) 
  {
    case "shadow":
      $bttnImage    = "lif_shd.xpm";
      break;
    case "coordsys":
      $bttnImage    = "lif_cs.xpm";
      break;
    case "texture":
    default:
      $bttnImage    = "lif_tex.xpm";
      break;  
  }             
  $bttnImage        = (liquidGetHome()+"/icons/"+$bttnImage);
  
  string  $saveParent   = $gLiquid_currentAEParent;
  string  $formLayoutCtl  = $ctlName + "_FRM";
  string  $buttonCtl    = $ctlName + "_BUT";
  string  $textFieldCtl = $ctlName;

  if ( !`control -q -ex ($ctlName)` )
  {
    formLayout -p $gLiquid_currentAEParent -visible $visible -enable $enable $formLayoutCtl;
    textFieldGrp -p $formLayoutCtl -cw 2 195 -label $label -ann $description $textFieldCtl;
    iconTextButton  -p $formLayoutCtl
            -style "iconOnly"
            -c $myFileCommand
            -w 29
            -h 19
            -mw 0
            -mh 0
            -i $bttnImage
            $buttonCtl;
    // setParent ..;
    liquidAddTextureViewerMenu( $textFieldCtl, $plug ); 
    if (`about -mac`)
    {
      formLayout  -e
            -af $textFieldCtl top     0
            -af $textFieldCtl left    0
            -af $textFieldCtl right   31
            -af $textFieldCtl top     2
            -af $textFieldCtl right   5
            $formLayoutCtl;
    }
    else
    {
      formLayout  -e
            -af $textFieldCtl top     0
            -af $textFieldCtl left    0
                        -af $buttonCtl    top     2
                        -ac $buttonCtl    left    0 $textFieldCtl
                        $formLayoutCtl;
    }
  }
  else
  {
    iconTextButton  -e -c $myFileCommand $buttonCtl;
    textFieldGrp  -e -ann $description $textFieldCtl;
  }
  
  liquidAE_LifStringOverride( $attr, $ctlName );
  connectControl -index 2 $ctlName $plug;
          
  $gLiquid_currentAEParent = $saveParent;
  setParent $saveParent;
  return $formLayoutCtl;
}

// Doesn't seem to ever be called ?
global proc string liquidAE_LifString_shaderNodeDrop (string $sourceNode, string $destNode) 
{
  print ("Shader Node Drop! " + $sourceNode + ", dest node" + $destNode + "\n");
  return "connect to node";
}

// Doesn't seem to ever be called ?
global proc string liquidAE_LifString_shaderAttrDrop (string $sourceNode, string $destAttr) 
{
  print ( "Shader Attr Drop! "+ $sourceNode + ", dest attr" + $destAttr + "\n" );
  return "connect to attr";
}

// Doesn't seem to ever be called ?
// ymesh: Yes. If we provide 3 argument to the function
global proc string liquidAE_LifString_shaderConnectToExisting ( string $plug, string $flag, string $node ) 
{
  print ( "connect existing: " + $plug + " (flag: " + $flag + ") node: " + $node + "\n" );
  connectAttr ( $node + ".message" ) $plug;
  return "connect existing";
}

// This works, when the "map" button is pressed
global proc string liquidAE_LifString_shaderCreateNew (string $plug) 
{
  // print ("Shader Create New: "+$plug+"\n");
  string $node = `shadingNode -asUtility liquidCoShader`; 
  connectAttr ($node+".message") $plug;
  return $node;
}

// This works, used to show the correct name in the control
global proc string liquidAE_LifString_shaderDefaultTraversal (string $plug)
{
  string $sourceNode  = "";
  if ( !objExists($plug) )
  {
    warning("[liquidAE_LifString_shaderDefaultTraversal] plug "+$plug+" doesn't exist !");
    return "";
  }
  string $conn[] = `listConnections -t liquidCoShader -s true -d false -p true $plug`;
  if ( size($conn) ) 
  {
    string $sourcePlug  = $conn[0];
    if ( $sourcePlug != "" ) 
    {
      $sourceNode = match("^[^\.]+", $sourcePlug);  // source node
      // string $sourceAttr = match("[\.].+$", $sourcePlug);  // source attribute
      // $sourceAttr      = substring($sourceAttr, 2, size($sourceAttr));
      // print ("Source is: "+$sourceNode+"."+$sourceAttr+"\n");
    }
  }
  ltrace("\t[liquidAE_LifString_shaderDefaultTraversal] on "+$plug+" yields "+$sourceNode+"\n");
  return $sourceNode;
}

/*
 -dropCallback(-dpc)     script     createedit
  Adds a callback that is called when a drag and drop operation is released above the drop site. The MEL version of the callback is of the form:
/
 -attrNavDecision(-and)      name string    
  The first argument is the name of an attribute. The button will be attached to the attribute so the button can be kept in synch with the attribute. The second argument is the navigatorDecisionString that can guide the behaviour that the navigator implements.
-createNew(-cn)   string  
  The script to execute when a new "connection" is requested.
-connectToExisting(-ce)   string  
  The script to execute when a connection should be made to an existing node.
-connectNodeToDropped(-cnd)   string  
  The script to execute when a node is dragged and dropped onto a node (the multilister issues this). Your script should take in two arguments: the source node and destination node respectively.
-connectAttrToDropped(-cad)   string  
  The script to execute when a node is dragged and dropped onto an attribute (multilister dnd attribute editor). Your script should take in two arguments: the source node and destination attribute respectively. 
 -disconnect(-d)     string     
  The script to execute when a "disconnection" is requested. 
global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type) 
*/

global proc string liquidAE_LifString_shader( string $paramName, string $attr, string $subtype, string $label, string $range[], string $description, int $state )
{
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAEShader;

  ltrace ("\t[liquidAE_LifString_shader] param: "+$paramName+", attr: "+$attr+", subtype:"+$subtype+", label: "+$label+", range: ["+stringArrayToString($range, " ")+"], state: "+$state+", desc: "+$description);

  string  $subtypes[] = stringToStringArray( $subtype, "|");
  int     $ns       = size($subtypes);
  string  $stype    = $subtypes[0];
  string  $accept   = $subtypes[$ns - 1];

  string  $plug   = ($gLiquid_currentAENode+"."+$attr);
  // string $mayaType = `getAttr -typ $plug`;
  string $ctlName = controlName( $paramName);
  int   $visible  = liquidLifVisible($state);
  int   $enable   = liquidLifEnable($state);

  if ( !`control -q -ex ($ctlName)` ) 
  {
    string $attrNavCtl  = `attrNavigationControlGrp
                  -p $gLiquid_currentAEParent
                  -at $plug
                  -and $plug "liquidCoShader" 
                  -cw 2 195 -cw 3 32            
                  -label $label -ann $description
                  -visible $visible -enable $enable
                  -dtv ("liquidAE_LifString_shaderDefaultTraversal "+$plug)
                  -ce ("liquidAE_LifString_shaderConnectToExisting "+$plug)
                  -cn ("liquidAE_LifString_shaderCreateNew "+$plug)
                  -cnd ("liquidAE_LifString_shaderNodeDrop")
                  -cad ("liquidAE_LifString_shaderAttrDrop")
                  $ctlName`;
  } 
  else 
  {
    attrNavigationControlGrp  -e -label $label -ann $description
                  -at $plug
                  -and $plug "liquidCoShader"
                  -dtv ("liquidAE_LifString_shaderDefaultTraversal "+$plug)
                  -ce ("liquidAE_LifString_shaderConnectToExisting "+$plug)
                  -cn ("liquidAE_LifString_shaderCreateNew "+$plug)
                  -cnd ("liquidAE_LifString_shaderNodeDrop")
                  -cad ("liquidAE_LifString_shaderAttrDrop")
                  $ctlName;
    // To force a refresh
    attrNavigationControlGrp  -e -at $plug -and $plug "liquidCoShader" $ctlName;
  }
  liquidAE_LifStringOverride( $attr, $ctlName );
  
  return $ctlName;
}


global proc string liquidAE_LifString_field( string $paramName, string $attr, string $label, string $range[], string $description, int $state )
{
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAEShader;

  ltrace ("\t[liquidAE_LifString_field] param: "+$paramName+", attr: "+$attr+", label: "+$label+", range: ["+stringArrayToString($range, " ")+"], state: "+$state+", desc: "+$description);


  string  $plug   = ($gLiquid_currentAENode+"."+$attr);
  // string $mayaType = `getAttr -typ $plug`;
  string  $ctlName  = controlName( $paramName);
  int   $visible  = liquidLifVisible($state);
  int   $enable   = liquidLifEnable($state);
  string $txtFieldCtl = $ctlName;
  
  if ( !`control -q -ex ($ctlName)` ) 
  {
    $txtFieldCtl = `textFieldGrp -p $gLiquid_currentAEParent
                    -label $label -ann $description
                    -visible $visible -enable $enable
                    $ctlName`;
  } 
  else 
  {
    textFieldGrp -e -ann $description $ctlName;
  }
  liquidAE_LifStringOverride( $attr, $ctlName );
  connectControl -index 2 $ctlName $plug;
  
  return $ctlName;
  
}


global proc string liquidAE_LifString( string $paramName, string $attr, string $subtype, string $label, string $range[], string $description, int $state )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  string      $resultCtl;
  
  ltrace ("[liquidAE_LifString] on "+$gLiquid_currentAENode+" for "+$paramName+", UI type "+$subtype
      + ", label "+$label+",range ["+stringArrayToString($range, " ")+"], state "+$state+", desc "+$description);
          
  string  $subtypes[] = stringToStringArray( $subtype, "|");
  string  $stype    = $subtypes[0];

  // save UI parent
  string  $saveParent = $gLiquid_currentAEParent;
  setParent $gLiquid_currentAEParent;
    
  switch ( $stype ) 
  {
    case "selector":
      $resultCtl = liquidAE_Lif_selector( $paramName, "string", $attr, $label, $range, $description, $state );
      break;
    case "texture":
    case "shadow":
    case "coordsys":
      $resultCtl = liquidAE_LifString_browser( $paramName, $attr, $stype, $label, $range, $description, $state );
      break; 
    case "shader":      // TODO : allow more subtypes, shader texture, shader component, etc 
      $resultCtl = liquidAE_LifString_shader( $paramName, $attr, $subtype, $label, $range, $description, $state );
      break;                
    case "field":       
    default :
      $resultCtl = liquidAE_LifString_field( $paramName, $attr, $label, $range, $description, $state );
      break;
  }

  // restore saved parent
  $gLiquid_currentAEParent = $saveParent;
  setParent $gLiquid_currentAEParent;
    
  ltrace ("[liquidAE_LifString] done!");

  return $resultCtl;
}

/********************************************************************
  Generic single parameter procedures that calls the above
********************************************************************/
global proc string liquidAE_LifParameter( string $paramName, int $index, string $paramType, 
                      string $subtype, string $label, string $range[],
                      string $description, int $state )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;

  string $createdControl = "";          // Warning, relative name, not full path

  ltrace ("[liquidAE_LifParameter] on "+$gLiquid_currentAENode+" for "+$paramName+", index "+$index+", type "+$paramType+" ("+$subtype+")"
      + ", label "+$label+",range ["+stringArrayToString($range, " ")+"], state "+$state+", desc "+$description);
    
  // error checking : if the param does not exist, we might have a bad lif
  string $baseattr  = $paramName;
  string $baseplug  = ($gLiquid_currentAENode+"."+$baseattr);
  if ( ! objExists( $baseplug ) ) 
  {
    warning ("[liquidAE_LifParameter] "+$baseplug+" does not exist ! Your Lif file might be obsolete...");
    return $createdControl;
  }
    
  // Multiples labels and subtypes are possible for fixed size arrays elements
  string  $subtypes[]   = stringToStringArray( $subtype, "|");
  int   $nsubtypes    = size($subtypes);
  string  $labels[]   = stringToStringArray( $label, "|");
  int   $nlabels    = size($labels);
  
  int   $isElement    = ($index >= 0);
  // int    $collapse   = liquidLifCollapse($state);
  int   $visible    = liquidLifVisible($state);
  int   $enable     = liquidLifEnable($state);
  int   $keyable    = liquidLifKeyable($state); 
  setAttr -k $keyable $baseplug;

  // Save parent for restoration at proc end
  string $saveParent = $gLiquid_currentAEParent;
  setParent $gLiquid_currentAEParent;
  
  string  $ename      = $paramName;
  string  $eattr      = $ename;
  string  $eplug      = $baseplug;
  string  $elabel     = $labels[0];
  string  $esubtype   = $subtypes[0];
  if ( $isElement ) 
  {
    string  $arrayNotation  = ("["+$index+"]");
    $ename          += $arrayNotation;
    $eattr          += $arrayNotation;
    $eplug          += $arrayNotation;
    $elabel         = (($nlabels > 1) && ($index < $nlabels)) ? $labels[$index] : ($elabel+$arrayNotation);
    $esubtype       = (($nsubtypes > 1) && ($index < $nsubtypes)) ? $subtypes[$index] : $esubtype;
    setAttr -k $keyable $eplug;
  }
  switch ( $paramType ) 
  {
    case "float":
      $createdControl = liquidAE_LifFloat( $ename, $eattr, $esubtype, $elabel, $range, $description, $state );
      break;
    case "color":
      if ( objExists($eplug+"."+$baseattr+"R") )  // maybe not a compound
      {
        setAttr -k $keyable ($eplug+"."+$baseattr+"R");
        setAttr -k $keyable ($eplug+"."+$baseattr+"G");
        setAttr -k $keyable ($eplug+"."+$baseattr+"B");
      }
      $createdControl = liquidAE_LifColor( $ename, $eattr, $esubtype, $elabel, $range, $description, $state );
      break;  
    case "point":
    case "vector":        
    case "normal":
      if ( objExists($eplug+"."+$baseattr+"X") )  // maybe not a compound
      {
        setAttr -k $keyable ($eplug+"."+$baseattr+"X");
        setAttr -k $keyable ($eplug+"."+$baseattr+"Y");
        setAttr -k $keyable ($eplug+"."+$baseattr+"Z");
      }
      $createdControl = liquidAE_LifVector( $ename, $eattr, $esubtype, $elabel, $range, $description, $state );
      break;
    case "matrix":
      $createdControl = liquidAE_LifMatrix( $ename, $eattr, $esubtype, $elabel, $range, $description, $state );
      break;
    case "string":
    case "shader":
      $createdControl = liquidAE_LifString( $ename, $eattr, $esubtype, $elabel, $range, $description, $state );
      break;
    default :
      warning ("[liquidAE_LifParameter] \""+$paramType+"\" not handled yet !"); 
      break;      
  }

  // restore saved parent and template
  $gLiquid_currentAEParent = $saveParent;
  setParent $gLiquid_currentAEParent;

  // return the top most create control
  return $createdControl;
}

/********************************************************************
  Multiple paremeters: groups, arrays, spline gradients etc
********************************************************************/

/********************************************************************
  Simple UI group
********************************************************************/

// Creates the form layout for a group
global proc string liquidAE_LifGrp( string $label, float $state )
{
  global string $gLiquid_currentAEParent;
  global string $gAEFocusNode;              // TODO : wtf is the difference between these both?
  global string $gLiquid_currentAENode;     
  global string $gLiquid_currentAEShader;
  
  ltrace ("[liquidAE_LifGrp] on "+$gLiquid_currentAENode+" for "+$label+", state "+$state+", shader "+$gLiquid_currentAEShader);

  int $collapse = liquidLifCollapse($state);
  int $visible  = liquidLifVisible($state);
  int $enable   = liquidLifEnable($state);

  setUITemplate -pst attributeEditorTemplate;

  switch ( $label ) 
  {
    case "end":
      // print ("Group end, old parent "+$gLiquid_currentAEParent);
      setParent $gLiquid_currentAEParent;
      setParent ..;
      setParent ..;
      // All other procs work with relative paths, but now that we got one layout per window shouldn't a problem
      // TODO : rework this anyway
      $gLiquid_currentAEParent  = `setParent -q`;
      // print (", New parent "+$gLiquid_currentAEParent+"\n");
      // maybe add a test here to check we are still in the cache layout
      break;
    default:
      // print ("Group start old parent "+$gLiquid_currentAEParent);
      string  $frameName  = controlName( $label )+"GRP";
      string  $columnName = controlName( $label )+"COL"; 
      if ( !`frameLayout -q -ex $frameName` ) 
      {
        frameLayout -p $gLiquid_currentAEParent -l $label 
                    -vis $visible -en $enable -cl $collapse
                    $frameName;
        columnLayout -p $frameName $columnName;
      }
      $gLiquid_currentAEParent  = $columnName;
      // print (", New parent "+$gLiquid_currentAEParent+"\n");
      break;
  }

  setUITemplate -ppt;
  setParent $gLiquid_currentAEParent;
  
  return $frameName;
}

/********************************************************************
  Arrays of parameters
********************************************************************/

// Delete all isntances of array plugs at this index
proc deleteArrayPlugs(int $index, string $plugs[])
{
  ltrace("deleteArrayPlugs at index "+$index+" for "+stringArrayToString($plugs, " "));
  
  for ( $plug in $plugs ) 
  {
  
    // $indices = `getAttr -mi $plug`;
    // print ("Existing indices for "+$plug+" at liquidAE_LifArrayRemoveItem");
    // for ($i in $indices) {
    //  print (" "+$i);
    // }
    // print ("\n");  
      
    // print ("Removing "+($plug+"["+$index+"]")+"\n");
    removeMultiInstance -b true ($plug+"["+$index+"]"); 
    
    // $indices = `getAttr -mi $plug`;
    // print ("Existing indices for "+$plug+" at liquidAE_LifArrayRemoveItem");
    // for ($i in $indices) {
    //  print (" "+$i);
    // }
    // print ("\n");    
  
  }
}

// Delete all instances of plugs that are not in sync with main (first) plug
proc cleanupArrayPlugs(string $plugs[])
{
  ltrace("cleanupArrayPlugs for "+stringArrayToString($plugs, " "));

  string  $mainPlug   = $plugs[0];
  int   $mainIndex;
  int   $mainIndices[]  = `getAttr -mi $mainPlug`;
  int   $mni      = size($mainIndices);

  // print ("Existing indices for "+$mainPlug+" at cleanupArrayPlugs");
  // for ($i in $mainIndices) {
  //  print (" "+$i);
  // }
  // print ("\n");
  
  int   $indices[];
  int   $index, $keep;
  
  string  $plug;
  int   $np   = size($plugs);
  for ( $p = 1; $p < $np ; $p++ ) 
  {
    $plug     = $plugs[$p];
    $indices    = `getAttr -mi $plug`;
    
    // print ("Existing indices for "+$plug+" at cleanupArrayPlugs");
    // for ($i in $indices) {
    //  print (" "+$i);
    // }
    // print ("\n");    
    
    for ( $index in $indices ) 
    {
      $keep     = 0;
      for ( $mainIndex in $mainIndices ) 
      {
        if ( $mainIndex == $index ) 
        {
          $keep = 1;
          break;
        }
      }
      if ( ! $keep ) 
      {
        // print ("Removing "+$index+"\n");
        removeMultiInstance -b true ($plug+"["+$index+"]");
      }
    }
  }
} 
        
// Copy all plugs for one array element
proc copyArrayPlugs(int $srcIndex, int $dstIndex, string $plugs[])
{
  // print ("copyArrayPlugs copy from index "+$srcIndex+" to "+$dstIndex+" for "+stringArrayToString($plugs, " ")+"\n");

  for ( $plug in $plugs ) 
  {
    copyPlug ( ($plug+"["+$srcIndex+"]"), ($plug+"["+$dstIndex+"]"), 1 );
  }
}

// Recursive sub proc for liquidAE_LifArrayMoveRow
proc int copyArrayElements(int $origSrcIndex, int $srcIndex, int $dstIndex, int $indices[], string $plugs[])
{
  // print ("copyArrayElements copy orig src: "+$origSrcIndex+", src: "+$srcIndex+", dst: "+$dstIndex+" for "+stringArrayToString($plugs, " ")+"\n");

  int   $movedSrcIndex  = $origSrcIndex;
  int   $index;
  int   $tail[];  
  int   $ni       = size($indices);
  int   $nt       = 0;
  for ( $i = 0; $i < $ni ; $i++ ) 
  {
    $index = $indices[$i];
    if ( $index == $dstIndex ) 
    {
      for ( $j = $i + 1; $j < $ni ; $j++ ) 
      {
        $tail[$nt++]    = $indices[$j];
      }   
      $movedSrcIndex    = copyArrayElements($origSrcIndex, $dstIndex, $dstIndex+1, $tail, $plugs);
      break;
    }
  }
  
  copyArrayPlugs($srcIndex, $dstIndex, $plugs); 
  if ( $srcIndex == $movedSrcIndex ) 
  {
    $movedSrcIndex      = $dstIndex;
  }
  
  return $movedSrcIndex;
}

// Compact the array and return the existing indices
global proc liquidAE_LifArrayCompact(string $plugs[], int $cleanUp)
{
  liquidAE_LifArrayCompactById($plugs, $cleanUp, 0);
}

//! updating the node's container
global proc liquidUpdateAEContainer(string $node)
{
  string $container = `container -q -findContainer $node`;
  if ( $container != "" )
  {
    if ( objExists($container+".duNullAttribute") )
    {
      deleteAttr ($container+".duNullAttribute");
    }
    else
    {
      addAttr -dt "string" -ln "duNullAttribute" $container;
    }
  }
}

// Compact the array and return the existing indices
global proc liquidAE_LifArrayCompactById(string $plugs[], int $cleanUp, int $plugId)
{
  int $index;
  int $indices[] = `getAttr -mi $plugs[$plugId]`;
  int $ni = size($indices);
  int $i = 0;
  int $j = 0;
  while ( $i < $ni )
  {
    $index  = $indices[$i++];
    if ( $j < $index )
    {
      // Hole there, compact
      copyArrayPlugs( $index, $j, $plugs );
      $j++;
    }
    else
    {
      // No hole at this index, continue
      $j  = $index + 1;
    }
  }
  // Delete the now duplicated multi instances of $gradAttr at the end of the array
  for ( $i = 0 ; $i < $ni ; $i++ )
  {
    $index  = $indices[$i];
    if ( $index >= $j )
    {
      deleteArrayPlugs( $index, $plugs );
    }
  }
  if ( $cleanUp )
  {
    // Cleanup the secondary plugs
    if ( size($plugs) > 1)
    {
      cleanupArrayPlugs( $plugs );
    }
  }
}

// Resizable array add 
global proc liquidAE_LifArrayAddItem(string $node, string $arrayAttributes[])
{
  ltrace ("[liquidAE_LifArrayAddItem] on "+$node+" for "+stringArrayToString($arrayAttributes, " "));
  // print ("[liquidAE_LifArrayAddItem] on "+$node+" for "+stringArrayToString($arrayAttributes, " ")+"\n");
                    
  // Find the next available index, we're indexed on the first array as "main"
  int   $na       = 0;
  string  $mainMultiPlug  = ($node+"."+$arrayAttributes[0]);  
  if( `getAttr -s $mainMultiPlug` > 0 )
  {
    int $ids[]  = `getAttr -multiIndices $mainMultiPlug`;
    for( $i in $ids ) 
    {
      // Just take highest
      if ( $i >= $na ) 
      {
        $na = $i + 1;
      }
    }
  }
  // Create the new plugs.
  string  $plug;
  for ($attr in $arrayAttributes)
  {
    $plug = ($node+"."+$attr+"["+$na+"]");
    catchQuiet( `getAttr -type $plug`);
  }

  liquidUpdateAEContainer($node);
}

// Resizable array remove 
global proc liquidAE_LifArrayRemoveItem(string $widget, int $index, string $plugs[])
{
  ltrace ("[liquidAE_LifArrayRemoveItem] "+$widget+", at index "+$index+" for "+stringArrayToString($plugs, " "));
  // print ("[liquidAE_LifArrayRemoveItem] "+$widget+", at index "+$index+" for "+stringArrayToString($plugs, " ")+"\n");

  string $parentWidget  = "";
  if ( `layout -q -ex $widget` ) 
  {
    $parentWidget     = `layout -q -p $widget`;
    // if (`layout -q -ex $parentWidget`) {
    //  catch(`layout -e -vis false $parentWidget`);
    // }
    catch(`deleteUI $widget`);
  }
  deleteArrayPlugs($index, $plugs);
  
  liquidAE_LifArrayCompact($plugs, 0);
  // Compact and cleanup array after a remove   
  // if (`layout -q -ex $parentWidget`) {
  //  catch(`layout -e -vis true $parentWidget`);
  // }
}
    
// Will copy row for array element of index $srcIndex to $dstIndex, pushing all rows
// at $dstIndex and above by 1
global proc int liquidAE_LifArrayCopyRow(int $srcIndex, int $dstIndex, string $plugs[])
{
  ltrace ("[liquidAE_LifArrayCopyRow] copying "+stringArrayToString($plugs, " ")+" from index "+$srcIndex+" to "+$dstIndex);
  // print ("[liquidAE_LifArrayCopyRow] copying "+stringArrayToString($plugs, " ")+" from index "+$srcIndex+" to "+$dstIndex+"\n");
  
  int   $index;
  int   $tail[];  
  int   $indices[]    = `getAttr -mi $plugs[0]`;
  int   $ni       = size($indices);
  int   $nt       = 0;
  int   $last     = 0;
  
  int   $movedSrcIndex  = $srcIndex;
  int   $movedDstIndex  = $dstIndex;
  for ( $i = 0; $i < $ni; $i++ ) 
  {
    $index          = $indices[$i];
    // Is destination index already occupied ?
    if ( $index == $dstIndex ) 
    {      
      if ( ($dstIndex - 1) > $last ) 
      {
        // Since we insert at $dstIndex, if there is a hole just before, we can save some work
        $movedDstIndex    = $dstIndex - 1;
      } 
      else 
      {
        // Otherwise we'll have to offset all indices until next hole
        for ($j = $i + 1; $j < $ni; $j++ ) 
        {
          $tail[$nt++] = $indices[$j];
        }
        $movedSrcIndex = copyArrayElements( $srcIndex, $dstIndex, $dstIndex+1, $tail, $plugs );
      }
      break;
    }
    $last         = $index;
  }
  // print ("Final copy from index "+$movedSrcIndex+" to "+$movedDstIndex+"\n");
  copyArrayPlugs ( $movedSrcIndex, $movedDstIndex, $plugs );
  // If it's a move, need to delete $movedSrcIndex
  return $movedSrcIndex;

}

// Will copy row then delete src row
global proc liquidAE_LifArrayMoveRow(int $srcIndex, int $dstIndex, string $plugs[])
{
  ltrace ("[liquidAE_LifArrayMoveRow] moving "+stringArrayToString($plugs, " ")+" from index "+$srcIndex+" to "+$dstIndex);
  // print ("[liquidAE_LifArrayMoveRow] moving "+stringArrayToString($plugs, " ")+" from index "+$srcIndex+" to "+$dstIndex+"\n");

  int $newSrcIndex  = liquidAE_LifArrayCopyRow( $srcIndex, $dstIndex, $plugs );
  
  liquidAE_LifArrayRemoveItem( "", $newSrcIndex, $plugs );
  liquidAE_LifArrayCompact( $plugs, 1 );
}

// For ordered resizable array, drag and drop
global proc string[] liquidAE_LifArrayDragRow(string $plugs[], string $dragControl, int $x, int $y, int $mods) 
{
  ltrace ("[liquidAE_LifArrayDragRow] x: "+$x+", y: "+$y+", mods: "+$mods+" for plugs "+stringArrayToString($plugs, " ")
      +", Dragctl: "+$dragControl+"\n");
  // print ("[liquidAE_LifArrayDragRow] x: "+$x+", y: "+$y+", mods: "+$mods+" for plugs "+stringArrayToString($plugs, " ")
  //    +", Dragctl: "+$dragControl+"\n");

  return $plugs;
}

global proc liquidAE_LifArrayDropRow(string $mainPlug, string $dragControl, string $dropControl, string $plugs[], int $x, int $y, int $type) 
{
  string  $dragName, $dropName;
  int   $dragIndex, $dropIndex, $movedSrcIndex;
  string  $controls[];
  int   $nc;
  $nc     = tokenize($dragControl, "|", $controls);
  $dragName = $controls[$nc-1];
  $dragIndex  = int(match("^[0-9]+", match("[0-9]+_LIF[A-Z]*$", $dragName))); 
  $nc     = tokenize($dropControl, "|", $controls);
  $dropName = $controls[$nc-1];
  $dropIndex  = int(match("^[0-9]+", match("[0-9]+_LIF[A-Z]*$", $dropName))); 
  
  ltrace ("[liquidAE_LifArrayDropRow] from index "+$dragIndex+" to "+$dropIndex+" for "+stringArrayToString($plugs, " ")
        +" (control "+$dragName+" to "+$dropName+", type "+$type+")");

  global string $gLiquid_currentAENode;
  string $moveCallbackProcName;
  if ( attributeExists("liquidAEMoveElementCallback", $gLiquid_currentAENode) )
  {
    $moveCallbackProcName = `getAttr ($gLiquid_currentAENode+".liquidAEMoveElementCallback")`;
  }
  else
  {
    $moveCallbackProcName = "liquidAE_LifArrayMoveRow";
  }

  $srcIndex = $dragIndex; 
  if ( $mainPlug == $plugs[0] )
  {
    if ( $dropIndex > $dragIndex )
    {
      $srcIndex = eval($moveCallbackProcName+"("+$dragIndex+", "+($dropIndex+1)+", {\""+stringArrayToString($plugs, "\", \"")+"\"})");
    }
    else if ( $dropIndex < $dragIndex )
    {
      $srcIndex = eval($moveCallbackProcName+"("+$dragIndex+", "+$dropIndex+", {\""+stringArrayToString($plugs, "\", \"")+"\"})");
    }
  }
  else
  {
    ltrace ("[liquidAE_LifArrayDropRow] cancelled as drag and drop arrays do not match");
    // print ("[liquidAE_LifArrayDropRow] cancelled as drag and drop arrays do not match\n");
  }
}

/********************************************************************
  Lists (Arrays) of paremeters, resizable, reorderable, element grouping
********************************************************************/

// Type currently always "list" but can be used to create more specific lists
global proc string liquidAE_LifArray( string $type, string $label, string $description, int $state,
                    int $arraySize, string $elementParam[], string $elementLifCmd[]
                  )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  global int    $gLiquid_maxDisplayElements;

  int $i;
  int $enableAddElement = 1;
  int $enableRemoveElement = 1;
  int $enableMoveElement = 1;
  if ( attributeExists("liquidAEEnableAddElement", $gLiquid_currentAENode) )
  {
    $enableAddElement = `getAttr ($gLiquid_currentAENode+".liquidAEEnableAddElement")`;
  }
  if ( attributeExists("liquidAEEnableRemoveElement", $gLiquid_currentAENode) )
  {
    $enableRemoveElement = `getAttr ($gLiquid_currentAENode+".liquidAEEnableRemoveElement")`;
  }
  if ( attributeExists("liquidAEEnableMoveElement", $gLiquid_currentAENode) )
  {
    $enableMoveElement = `getAttr ($gLiquid_currentAENode+".liquidAEEnableMoveElement")`;
  }

  // Based on the size and indices of the first attribute / parameter always
  int   $indi[]     = `getAttr -multiIndices  ($gLiquid_currentAENode+"."+$elementParam[0])`;

//  print ("Existing indices at Array");
//  for ($i in $indi) {
//    print (" "+$i);
//  }
//  print ("\n"); 


  ltrace ("[liquidAE_LifArray] on " +$gLiquid_currentAENode+", UI type "+$type + ", label "+$label+", size "+$arraySize                 
                    +" for "+stringArrayToString($elementParam, " ")
                    +", state "+$state+", desc "+$description);
//  print ("[liquidAE_LifArray] on "  +$gLiquid_currentAENode+", UI type "+$type + ", label "+$label+", size "+$arraySize                 
//                    +" for "+stringArrayToString($elementParam, " ")
//                    +", state "+$state+", desc "+$description+"\n");

  string  $node     = $gLiquid_currentAENode;         
  int   $np       = size($elementParam);
  // error checking : if the param does not exist, we might have a bad lif
  string  $plug;
  string  $elementAttr[];
  string  $elementPlug[];
  string  $elementLif[];
  int   $nparams    = 0;  
  for ( $i = 0; $i < $np; $i++ ) 
  {
    $plug = ($node+"."+$elementParam[$i]);
    if ( objExists( $plug ) ) 
    {
      $elementAttr[$nparams]  = $elementParam[$i];
      $elementPlug[$nparams]  = $plug;
      $elementLif[$nparams] = $elementLifCmd[$i];
      $nparams++;
    } 
    else 
    {
      warning ("[liquidAE_LifArray] "+$plug+" does not exist ! Your Lif file might be obsolete...");
    }
  }
  if ( $nparams == 0 ) return "";
  
  int   $resizable      = ($arraySize == 0);  
  string  $arrayName      = $elementAttr[0];
  string  $uniqueName     = $arrayName;
  string  $plugForGettingIndices = $elementPlug[0];
  // get larger element to set array name
  int $maxSize = -1;
  int $largerElementId = 0;
  if ( size($elementAttr)>1 )
  {
    $uniqueName = "";
    for ( $i = 0; $i < size( $elementAttr ); $i++ )
    {
      int $ids[] = `getAttr -mi ($gLiquid_currentAENode+"."+$elementAttr[$i])`;
      if ( size($ids) > $maxSize )
      {
        $maxSize = size($ids);
        $largerElementId = $i;
      }
      $uniqueName += $elementAttr[$i] + "_";
    }
    $arrayName = $elementAttr[$largerElementId];
    $plugForGettingIndices = $elementPlug[$largerElementId];
  }
  else
  {
    // just in case we display an attribute wich is part of a group
    string $group = liquidGetGroupForAttributes($gLiquid_currentAENode, $elementAttr[0]);
    if ( $group != "" )
    {
      string $subAttributes[] = liquidGetGroupSubAttributes($gLiquid_currentAENode, $group);
      int $largerElementIdInGroup = 0;
      for ( $i = 0; $i < size( $subAttributes ); $i++ )
      {
        int $ids[] = `getAttr -mi ($gLiquid_currentAENode+"."+$subAttributes[$i])`;
        if ( size($ids) > $maxSize )
        {
          $maxSize = size($ids);
          $largerElementIdInGroup = $i;
        }
      }
      $plugForGettingIndices = $gLiquid_currentAENode + "." + $subAttributes[$largerElementIdInGroup];
    }
  }
  
  string  $arrayLabel     = ($label == "") ? ($arrayName+"[]") : $label;  
  // Array frame state
  int   $collapse     = liquidLifCollapse($state);
  int   $visible      = liquidLifVisible($state);
  int   $enable       = liquidLifEnable($state);
  // int    $keyable    = liquidLifKeyable($state); 

    // Based on the size and indices of the first attribute / parameter always
  int   $indices[];
  int   $size;  
  if ( $resizable )
  {
    // Compact array (but no cleanup) if it's a resizable
    liquidAE_LifArrayCompactById($elementPlug, 0, $largerElementId);
    //$indices          = `getAttr -mi $elementPlug[$largerElementId]`;
    $indices          = `getAttr -mi $plugForGettingIndices`;
    $size           = size($indices);
  }
  else
  {
    // Non resizable arrays, fix number of indices should be 0 to $arraySize - 1 
    for ( $i = 0; $i < $arraySize; $i++ )
    {
      $indices[$i] = $i;
    }
    $size = $arraySize;
  }
  
  // print ("Existing indices at Array after compacting");
  // for ($i in $indices) {
  //  print (" "+$i);
  // }
  // print ("\n");  

  // Save parent for restoration at proc end
  string $saveParent = $gLiquid_currentAEParent;
  setParent $gLiquid_currentAEParent;
  setUITemplate -pst attributeEditorTemplate;
  
  // Create the array frame depending on array type
  string $arrayFrame      = controlName( $uniqueName )+"ARRAY";
  //string $arrayFramePath    = $arrayFrame;
  string $arrayColumn   = controlName( $uniqueName )+"ARCOL"; 
  //string $arrayColumnPath = $arrayColumn;
  string $addBttnName;
  //string $addBttnPath;
  string $addCmd;
  if ( $resizable )
  {
    $addBttnName = controlName($uniqueName)+"ARADD";
    string $callbackProcName;
    if ( attributeExists("liquidAEAddElementCallback", $gLiquid_currentAENode) )
    {
      $callbackProcName = `getAttr ($gLiquid_currentAENode+".liquidAEAddElementCallback")`;
    }
    else
    {
      $callbackProcName = "liquidAE_LifArrayAddItem";
    }
    if( $enableAddElement )
    {
      $addCmd = ($callbackProcName + "( \""+$gLiquid_currentAENode+"\", {\""+stringArrayToString($elementParam, "\", \"")+"\"} );");  
    }
    else
    {
      $addCmd = ""; 
    }
  }

  if ( !`frameLayout -q -ex $arrayFrame` )
  {
    frameLayout -p $gLiquid_currentAEParent
          // -borderVisible false -labelIndent 10 -font "smallPlainLabelFont"
          -cll true
          -label $label
          -ann $description
          -vis $visible
          -en $enable
          -cl $collapse
          -w 420
          $arrayFrame;
    // $arrayColumnPath     = `columnLayout -p $arrayFrame -cw 390 -adj true $arrayColumn`;
    columnLayout /*-adj true*/ -p $arrayFrame -columnAttach "both" 0 -cw 390 -ann $description $arrayColumn;
    // for resizable arrays add button to create new elements
    if ( $resizable )
    {
      rowLayout -en $enableAddElement /*-vis $enableAddElement*/ -nc 2 -ann $description (controlName( $uniqueName )+"ARADDROW");
      text -label "" -ann $description (controlName( $uniqueName )+"ARADDDUMMY");
      button -label "Add Element" -ann $description -c $addCmd $addBttnName;
    }
  }
  else if ( $resizable )
  {
    button -e -c $addCmd $addBttnName;
  }

  $gLiquid_currentAEParent  = $arrayColumn;
  setParent $arrayColumn; 
  
  // Disable the column array
  columnLayout -e -vis false $arrayColumn;

  string  $allPlugs, $dragCmd, $dropCmd;
  int   $tooMuch      = 0;
  // For resizables, delete rows that correspond to a no longuer existing array index,
  // prepare the drag and drop
  if ( $resizable )
  {
    $allPlugs         = ("{\""+stringArrayToString($elementPlug, "\",\"")+"\"}");
    $dragCmd          = ("liquidAE_LifArrayDragRow "+$allPlugs);
    $dropCmd          = ("liquidAE_LifArrayDropRow "+$elementPlug[$largerElementId]);
    string  $rows[]       = `columnLayout -q -childArray $arrayColumn`;
    int   $nr         = size($rows);
    int   $ri, $cr;
    // Actually delete all rows until I get this working properly?
    // Prb creates double refreshes and slows things down
    /*
    for ($r = 1; $r < $nr; $r++) {
      deleteUI  $rows[$r];
    }
    */
    // Delete orphaned or misplaced row widgets only
    $cr = 0;
    for ( $r = 1; $r < $nr; $r++ )
    {
      $ri   = int(match("^[0-9]+", match("[0-9]+_LIF[A-Z]*$", $rows[$r])));
      if ( ($cr < $size) && ($ri == $indices[$cr]) )
      {
        $cr += 1;
      }
      else
      {
        deleteUI  $rows[$r];
      }
    }
    if ( $size > $gLiquid_maxDisplayElements )
    {
      $tooMuch    = $size - $gLiquid_maxDisplayElements;
      $size     = $gLiquid_maxDisplayElements;
    }
    setUITemplate -pst attributeEditorMultiTemplate;      
  } 

  int     $index, $previous, $next;
  string  $arrayNotation; 
  string  $arrayElementName;
  string  $arrayElementLabel;
  //string  $rowName, $rowPath;
  string  $rowName;
  string  $rowFrameName;
  string  $rowColumnName;
  string  $cmd;
  string  $elementCtl[];
    
  // For the parameter or all paremeters that are array elements
  for ( $i = 0; $i < $size; $i++ )
  {
    $previous   = ($i > 0) ? $indices[$i-1] : -1;
    $index      = $indices[$i];
    $next       = (($i + 1) < $size ) ? $indices[$i+1] : -1;
    $arrayNotation    = ("["+$index+"]"); 
    $arrayElementName = $uniqueName + $arrayNotation;
    $arrayElementLabel = $arrayLabel + $arrayNotation;
    // Extra layout for resizable arrays, support for multiple labels for fixed size arrays
    if ( $resizable )
    {     
      $rowName = controlName( $arrayElementName )+"ROW";
      if ( !`formLayout -q -ex $rowName` )
      {
        //$rowPath      = `formLayout -p $gLiquid_currentAEParent -ann $arrayElementLabel $rowName`;                                                                  
        formLayout -p $gLiquid_currentAEParent -ann $arrayElementLabel $rowName;
      }
      if ( $enableMoveElement )
      {
        formLayout  -e -dgc $dragCmd -dpc $dropCmd $rowName;
      }
      else
      {
        formLayout  -e -dgc "" -dpc "" $rowName;
      }
      $gLiquid_currentAEParent = $rowName;
      // print ("Added row: "+$rowName+" for index "+$index+"\n");
    }
              
    // Extra layout, made visible for multiple elements
    int $visibleFrame   = ($nparams > 1);
    $rowFrameName     =   controlName( $arrayElementName )+"ROWFRAME";
    //string $rowFramePath  = $rowFrameName;
    $rowColumnName      =   controlName( $arrayElementName )+"ROWCOL";
    //string $rowColumnPath = $rowColumnName;       
    if ( !`frameLayout -q -ex $rowFrameName` )
    {
      frameLayout -p $gLiquid_currentAEParent
            -l $arrayElementLabel
            -cll $visibleFrame
            -cl false
            -lv $visibleFrame
            -bv $visibleFrame
            -labelIndent 10
            -font "smallPlainLabelFont"
            -borderStyle "etchedIn" 
            -w 377
            -ann $arrayElementLabel
            $rowFrameName;
    }
    if ($resizable)
    {
      frameLayout -e -dgc $dragCmd -dpc $dropCmd $rowFrameName;
    }
    frameLayout -e -h 23 $rowFrameName;

    //if ($nparams > 1)
    {
      if ( !`columnLayout -q -ex $rowColumnName` )
      {
        columnLayout  -p $rowFrameName
                -cw 377
                -adj true 
                -ann $arrayElementLabel
                $rowColumnName;
      }
      else
      {
        columnLayout -e -ann $arrayElementLabel $rowColumnName;
      }     
      $gLiquid_currentAEParent = $rowColumnName;
      setParent $rowColumnName;
    }
    //else
    //{
    //  $gLiquid_currentAEParent = $rowFrameName;
    //  setParent $rowFrameName;
    //}
          
    // Lif commands for all paramaters in array are in $elements
    // clear $elementCtl;
    for ( $e = 0; $e < $nparams; $e++ )
    {
      // print ("Adding param: "+$elementAttr[$e]+" under "+$gLiquid_currentAEParent+"\n");   
      $cmd          = substitute("#", $elementLif[$e], string($index));
      $elementCtl[$e]     = eval ($cmd);
    }
    // Add the extra "remove element" button for resizables 
    if ($resizable)
    {
      string $removeBttnName  = controlName( $arrayElementName )+"RMBTTN";
      //string $removeBttnPath  = $removeBttnName;
      string $removePopupName = controlName( $arrayElementName )+"RMBPOP";
      //string $removePopupPath = $removePopupName;

      string $removeCallbackProcName;
      string $moveCallbackProcName;
      if ( attributeExists("liquidAERemoveElementCallback", $gLiquid_currentAENode) )
      {
        $removeCallbackProcName = `getAttr ($gLiquid_currentAENode+".liquidAERemoveElementCallback")`;
      }
      else
      {
        $removeCallbackProcName = "liquidAE_LifArrayRemoveItem";
      }
      if ( attributeExists("liquidAEMoveElementCallback", $gLiquid_currentAENode) )
      {
        $moveCallbackProcName = `getAttr ($gLiquid_currentAENode+".liquidAEMoveElementCallback")`;
      }
      else
      {
        $moveCallbackProcName = "liquidAE_LifArrayMoveRow";
      }
      string $removeCmd = ( $removeCallbackProcName + "( \""+$rowName+"\", "+$index+", "+$allPlugs+" );liquidUpdateAEContainer( \"" + $gLiquid_currentAENode +"\");");
      if ( !`button -q -ex $removeBttnName` )
      { 
        int $height       = `layout -q -h $rowFrameName`;
        $height         = max(1, $height);
        // To make drag and drop easier for single elements, can do it on the button    
        button  -p $rowName
            -label "X"
            -ann "Move or Delete entry"
            -w 23
            -h $height
            -dgc $dragCmd -dpc $dropCmd
            -c $removeCmd
            $removeBttnName;
        popupMenu -p $removeBttnName -button 3 $removePopupName;
        string $menu1 = `menuItem -p $removePopupName -l "Move Up" -en ($previous >= 0)
              -c ($moveCallbackProcName + " "+$index+" "+$previous+" "+$allPlugs)`;
        string $menu2 = `menuItem -p $removePopupName -l "Move Down" -en ($next >= 0)
              -c ($moveCallbackProcName + " "+$index+" "+($next+1)+" "+$allPlugs)`;
        string $menu3 = `menuItem -p $removePopupName -l "Delete" -c $removeCmd`;

        if ( !$enableMoveElement )
        {
          menuItem -c "" -en 0 $menu1;
          menuItem -c "" -en 0 $menu2;
        }
                  
        // Attach to form
          formLayout  -edit     
              -attachForm   $rowFrameName "left"  0
              -attachForm   $rowFrameName "right" 23
              -attachForm   $rowFrameName "top" 0      
            -attachNone   $rowFrameName "bottom"
            
              -attachControl  $removeBttnName "left" 0 $rowFrameName
              // -attachNone    $rowFramePath "left"
              -attachForm   $removeBttnName "right" 0
              -attachForm   $removeBttnName "top" 0
              -attachNone   $rowFrameName "bottom"
              // -attachForm    $removeBttnPath "bottom" 0        
          $rowName;
        // Link height to frame height
        if ($visibleFrame)
        {
          button      -e -c $removeCmd -dgc $dragCmd -dpc $dropCmd $removeBttnName;
          string $cmd   = ("button -e -h (`layout -q -h "+$rowFrameName+"`) "+$removeBttnName);
          frameLayout   -e -cc $cmd -ec $cmd $rowFrameName;
        }                                   
      }
      else
      {
        string $popItems[]  = `popupMenu -q -itemArray $removePopupName`;
        if ( $enableMoveElement )
        {
          menuItem  -e -c ($moveCallbackProcName + " "+$index+" "+$previous+" "+$allPlugs)
                -en ($previous >= 0)
                $popItems[0];
          menuItem  -e -c ($moveCallbackProcName + " "+$index+" "+($next+1)+" "+$allPlugs)
                -en ($next >= 0)
                $popItems[1];
        }
        else
        {
          menuItem -e -c "" -en 0 $popItems[0];
          menuItem -e -c "" -en 0 $popItems[1];
        }
      }
      button -e -en $enableRemoveElement $removeBttnName;
    }
    // Back to column parent for next element
    $gLiquid_currentAEParent = $arrayColumn;
    setParent $arrayColumn;     
    // Resize column
    evalDeferred("liquidAE_ReBuildColumnSize " + $rowColumnName);
  }
  // If we have more elements that we can display
  if ( $resizable ) 
  {
    if ( $tooMuch ) 
    {
      string $txtName = controlName( $uniqueName )+"TXT";
      $txtName        = `text -l ($tooMuch+" elements not displayed") $txtName`;
    }
    setUITemplate -ppt;
  }
  
  // We're done so show the columnLayout
  columnLayout -e -vis true $arrayColumn;

  // restore saved parent and template
  setUITemplate -ppt;
  $gLiquid_currentAEParent = $saveParent;
  setParent $gLiquid_currentAEParent;

  // Return the top most control created (for callbacks)
  return $arrayFrame;
}


global proc liquidAE_ReBuildColumnSize(string $column)
{
  string $children[] = `layout -q -ca $column`;
  string $child;
  int $height = 1;
  for($child in $children)
  {
    $height += `layout -q -h $child`;
  }
  columnLayout -e -h $height $column;
}


/********************************************************************
  Gradients
********************************************************************/

// Reconnects the existing $gradAttr to the corresponding $valueAttr, $positionAttr and $interpAttr
// Recompacts the $gradAttr array as sparse indices will create interpretation problems for the shader
proc lifGradientAttr_connect( string $node, string $gradAttr, string $valueAttr, string $positionAttr, string $interpAttr, int $isColor )
{
  string  $gradPlug = ($node+"."+$gradAttr);
  int   $indices[]  = `getAttr -mi $gradPlug`;
  int   $ni     = size($indices);

  ltrace("\t[liquidLifWidgets.lifGradientAttr_connect] node "+$node+" for "+$ni+" entries \""+$gradAttr
      +"\", valueAttr \""+$valueAttr+"\", positionAttr \""+$positionAttr+"\", interpAttr \""+$interpAttr+"\"");

  // Compact the $gradAttr
  
  int   $i, $j;
  $i = $j = 0;
  while ( $i < $ni ) 
  {
    $index  = $indices[$i++];
    if ( $j < $index ) 
    {
      // Hole there, compact
      // Value
      if ( $isColor ) 
      {
        float $col[]  = `getAttr ($gradPlug+"["+$index+"]."+$gradAttr+"_Color")`;
        setAttr ($gradPlug+"["+$j+"]."+$gradAttr+"_Color") $col[0] $col[1] $col[2];
      } 
      else 
      {
        float $val  = `getAttr ($gradPlug+"["+$index+"]."+$gradAttr+"_FloatValue")`;
        setAttr ($gradPlug+"["+$j+"]."+$gradAttr+"_FloatValue") $val;
      }
      // Position
      float $pos    = `getAttr ($gradPlug+"["+$index+"]."+$gradAttr+"_Position")`;
      setAttr ($gradPlug+"["+$j+"]."+$gradAttr+"_Position") $pos;
      // Interp
      float $interp = `getAttr ($gradPlug+"["+$index+"]."+$gradAttr+"_Interp")`;
      setAttr ($gradPlug+"["+$j+"]."+$gradAttr+"_Interp") $interp;
      $j++;
    } 
    else 
    {
      // No hole at this index, continue
      $j  = $index + 1;
    }
  }
  // Delete the now duplicated multi instances of $gradAttr at the end of the array
  for ( $i = 0 ; $i < $ni; $i++ ) 
  {
    $index  = $indices[$i];
    if ( $index >= $j ) 
    {
      removeMultiInstance -b true ($gradPlug+"["+$index+"]");
    }
  }
  // Get the updated indices
  $indices    = `getAttr -mi $gradPlug`;
  $ni         = size($indices);
  
  // Reconnect the $gradAttr  
  
  string $source, $dest;
  string $conn[]; 
  for ( $i = 0; $i < $ni; $i++ ) 
  {
    $index = $indices[$i];
    // Values
    $source = ($gradPlug+"["+$index+"]."+$gradAttr);
    if ( $isColor ) 
    {
      $source += "_Color";
    } 
    else 
    {
      $source += "_FloatValue";
    }
    $dest = ($node+"."+$valueAttr+"["+$index+"]");  
    $conn = `listConnections -s true -d false -p true $dest`;
    // ltrace ("\t\t[liquidLifWidgets.lifGradientAttr_connect] "+$source+" to "+$dest);
    if ( $conn[0] != $source ) 
    {
      setAttr -lock off $dest;    
      catch(`connectAttr -f $source $dest`);
    }
    
    // Positions
    $source = ($gradPlug+"["+$index+"]."+$gradAttr+"_Position");
    $dest = ($node+"."+$positionAttr);
    if ( objExists( $dest ) ) 
    {
      setAttr -lock off $source;
      $dest += ("["+$index+"]");
      $conn = `listConnections -s true -d false -p true $dest`;
      // ltrace ("\t\t[liquidLifWidgets.lifGradientAttr_connect] "+$source+" to "+$dest);
      if ( $conn[0] != $source ) 
      {      
        setAttr -lock off $dest;
        catch(`connectAttr -f $source $dest`);
      }
    } 
    else 
    {
      setAttr -lock on $source;
    }
    
    // Interpolation
    $source = ($gradPlug+"["+$index+"]."+$gradAttr+"_Interp");
    $dest = ($node+"."+$interpAttr);
    if ( objExists( ($node+"."+$interpAttr) ) ) 
    {
      setAttr -lock off $source;
      // For this specific element
      if ( objExists($dest + "["+$index+"]") ) 
      {
        $dest += ("["+$index+"]");
        $conn = `listConnections -s true -d false -p true $dest`;
        // ltrace ("\t\t[liquidLifWidgets.lifGradientAttr_connect] "+$source+" to "+$dest);
        if ( $conn[0] != $source ) 
        {      
          setAttr -lock off $dest;
          catch(`connectAttr -f $source $dest`);
        }     
      } 
      else if ( $i == 0 ) 
      {
        $conn = `listConnections -s true -d false -p true $dest`;
        // ltrace ("\t\t[liquidLifWidgets.lifGradientAttr_connect] "+$source+" to "+$dest);
        if ( $conn[0] != $source ) 
        {      
          setAttr -lock off $dest;
          catch(`connectAttr -f $source $dest`);
        }
      }
    } 
    else 
    {
      setAttr -lock on $source;
    }
  }
  
  // Cleanup the unconnected destination attributes
  
  // Values
  $dest   = ($node+"."+$valueAttr);
  $indices  = `getAttr -mi $dest`;
  for ( $index in $indices ) 
  {
    $source = ($gradPlug+"["+$index+"]."+$gradAttr);
    if ( $isColor ) 
      $source += "_Color";
    else 
      $source += "_FloatValue";
    $dest   = ($node+"."+$valueAttr+"["+$index+"]");
    $conn   = `listConnections -s true -d false -p true $dest`;
    if ( $conn[0] != $source ) 
      removeMultiInstance -b true $dest;
  }
  // Positions 
  $dest   = ($node+"."+$positionAttr);
  if ( objExists($dest) ) 
  {
    $indices  = `getAttr -mi $dest`;
    for ( $index in $indices ) 
    {
      $source = ($gradPlug+"["+$index+"]."+$gradAttr+"_Position");
      $dest   = ($node+"."+$positionAttr+"["+$index+"]");
      $conn   = `listConnections -s true -d false -p true $dest`;
      if ( $conn[0] != $source ) 
        removeMultiInstance -b true $dest;
    }
  }
  // Interp   
  $dest   = ($node+"."+$interpAttr);
  if ( objExists($dest) ) 
  {
    $indices  = `getAttr -mi $dest`;
    for ( $index in $indices ) 
    {
      $source = ($gradPlug+"["+$index+"]."+$gradAttr+"_Interp");
      $dest   = ($node+"."+$interpAttr+"["+$index+"]");
      $conn   = `listConnections -s true -d false -p true $dest`;
      if ( $conn[0] != $source ) 
        removeMultiInstance -b true $dest;
    }
  } 
}

proc lifGradientAttr_init( string $node, string $gradAttr, string $valueAttr, string $positionAttr, string $interpAttr, int $isColor )
{
  $indices      = `getAttr -mi ($node+"."+$valueAttr)`;
  int $ni       = size($indices);
  if ( $ni == 0 ) 
  {
    // Gradient widgets without at least 1 entry behave strangely
    if ( $isColor ) 
      setAttr ($node+"."+$valueAttr+"["+0+"]") 0 0 0;
    else 
      setAttr ($node+"."+$valueAttr+"["+0+"]") 0;
    $indices = {0};
    $ni      = 1;
  }
  ltrace("\t[liquidLifWidgets.lifGradientAttr_init] node "+$node+" for "+$ni+" values,"
      +" valueAttr \""+$valueAttr+"\", positionAttr \""+$positionAttr+"\", interpAttr \""+$interpAttr+"\", gradAttr \""+$gradAttr+"\"");

  for ( $i = 0; $i < $ni; $i++ ) 
  {
    $index        = $indices[$i];
    // ltrace ("\t\t[liquidLifWidgets.lifGradientAttr_init] "+$node+" "+$valueAttr+"["+$index+"]");

    float $pos  = 0;
    if ( objExists( ($node+"."+$positionAttr+"["+$index+"]") ) ) 
      $pos    = `getAttr ($node+"."+$positionAttr+"["+$index+"]")`;
    else if ($ni > 0) 
      $pos    = ($i*(1/($ni-1)));
    float $interp = 3;
    if ( $interpAttr != "" ) 
    {
      if ( objExists( ($node+"."+$interpAttr+"["+$index+"]") ) ) 
        $interp = `getAttr ($node+"."+$interpAttr+"["+$index+"]")`;
      else 
        $interp = `getAttr ($node+"."+$interpAttr)`;
    }
  
    setAttr ($node+"."+$gradAttr+"["+$index+"]."+$gradAttr+"_Position") $pos;
    if ( $isColor ) 
    {
      float $col[]  = `getAttr ($node+"."+$valueAttr+"["+$index+"]")`;
      setAttr ($node+"."+$gradAttr+"["+$index+"]."+$gradAttr+"_ColorR")   $col[0];
      setAttr ($node+"."+$gradAttr+"["+$index+"]."+$gradAttr+"_ColorG")   $col[1];
      setAttr ($node+"."+$gradAttr+"["+$index+"]."+$gradAttr+"_ColorB")   $col[2];
    } 
    else 
    {
      float $val  = `getAttr ($node+"."+$valueAttr+"["+$index+"]")`;
      setAttr ($node+"."+$gradAttr+"["+$index+"]."+$gradAttr+"_FloatValue")  $val;
    }
    setAttr ($node+"."+$gradAttr+"["+$index+"]."+$gradAttr+"_Interp")   $interp;  
  }
}

// Create the compound attribute for ramp widget, init and connect
proc string lifGradientAttr_create( string $node, string $valueAttr, string $positionAttr, string $interpAttr, int $isColor )
{
  ltrace ("\t[liquidLifWidgets.lifGradientAtr_create]  node:"+$node+", valueAttr:"+$valueAttr+", positionAttr:"+$positionAttr+", interpAttr:"+$interpAttr+" )");

  string $gradAttr = ($valueAttr+"Lif");

  if ( !`objExists ($node+"."+$gradAttr)` ) 
  {
    // ltrace ("\t\t[liquidLifWidgets.lifGradientAtr_create] "+$node+" "+$valueAttr+"  >  "+$gradAttr);
    addAttr -hidden true -ln $gradAttr -attributeType compound -numberOfChildren 3 -multi $node;
    addAttr -hidden true -ln ($gradAttr+"_Position") -attributeType "float" -parent $gradAttr $node;
    if ( $isColor ) 
    {
      addAttr -hidden true -ln ($gradAttr+"_Color") -usedAsColor -attributeType float3 -parent $gradAttr $node;
      addAttr -hidden true -ln ($gradAttr+"_ColorR") -attributeType "float" -parent ($gradAttr+"_Color") $node;
      addAttr -hidden true -ln ($gradAttr+"_ColorG") -attributeType "float" -parent ($gradAttr+"_Color") $node;
      addAttr -hidden true -ln ($gradAttr+"_ColorB") -attributeType "float" -parent ($gradAttr+"_Color") $node;
    } 
    else 
      addAttr -hidden true -ln ($gradAttr+"_FloatValue") -attributeType "float" -parent $gradAttr $node;
    
    addAttr -hidden true -ln ($gradAttr+"_Interp") -attributeType "enum" -en "none:linear:smooth:spline" -parent $gradAttr $node;
  }

  return $gradAttr;
}

global proc lifGradient_unifyInterpolation( string $ctlName, string $attr )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  
  string  $node = $gLiquid_currentAENode;
  string  $plug = ($node+"."+$attr);

  string $currentParent = `setParent -q`;
  string $optionMenuCtl = `setParent $ctlName`;
  int $selected = `optionMenu -q -sl ($optionMenuCtl+"|optionMenu")` - 1;

  int $size = `getAttr -s $plug`;
  for ( $i=0; $i<$size; $i++ ) 
    setAttr ($plug+"["+$i+"]."+$attr+"_Interp") $selected;
  
  setParent $currentParent;
}


global proc lifGradient_connect( string $ctlName, string $attr, int $editButton )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  
  string  $node = $gLiquid_currentAENode;
  string  $plug = ($node+"."+$attr);
  
  ltrace ("\t[lifGradient_connect] for "+$plug+", shader "+$gLiquid_currentAEShader+", control: "+$ctlName);
  
  // Reconnect gradient
  gradientControl -e -at $plug $ctlName;
  // Reconnect button
  if ( $editButton ) 
  {
    string  $editBttnName = ($ctlName + "BTTN");
    button -e -c ("editRampAttribute "+$plug) $editBttnName;
  }
}


global proc string lifGradient_create( string $attr, string $label, string $description, int $state,
                      int $staticEntries, int $staticPositions, int $uniqueInterp,
                      int $adaptiveScaling, int $editButton )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  
  string  $node = $gLiquid_currentAENode;
  string  $plug = ($node+"."+$attr);
  
  ltrace ("\t[lifGradient_create] for "+$plug+", shader "+$gLiquid_currentAEShader+", label "+$label
        +", static entries "+$staticEntries+", static positions "+$staticPositions
        +", unique interp "+$uniqueInterp+", adaptative scaling "+$adaptiveScaling
        +", state "+$state+", description: "+$description );

  setParent $gLiquid_currentAEParent;

  string  $rampName = controlName( ($attr + "Ramp") );
  string  $scName   = controlName( ($attr + "Scc") );
  string  $spName   = controlName( ($attr + "Sp") );
  string  $siName   = controlName( ($attr + "Si") );

  string  $colEntryName = ($plug + "[0]." + $attr + "_ColorR");
  int   $isColor    = `objExists ($colEntryName)`;
  // State
  int   $collapse   = liquidLifCollapse($state);    
  int   $visible    = liquidLifVisible($state);
  int   $enable     = liquidLifEnable($state);
  
  string  $rampTopFrame = ($rampName + "TOP");
  frameLayout -p $gLiquid_currentAEParent -l $label
        -cll true -cl $collapse -lv true -bv true
        -w 420
        -vis $visible -en $enable 
        -labelIndent 10 -font "smallPlainLabelFont"
        -borderStyle "etchedIn" 
        -ann $description
        $rampTopFrame;
  string  $ramColName   = ($rampName + "COL");
  // string $ramColPath   = `columnLayout -p $rampTopPath -columnAttach "both" 2 -adj 1 -rowSpacing 2`;
  columnLayout -p $rampTopFrame -columnAttach "both" 0 -cw 390 -rowSpacing 2 -ann $description $ramColName;
  
  // ramp block
  string  $rampFormName = ($rampName + "FORM");
  formLayout  -p $ramColName $rampFormName;
  string  $spc      = `attrFieldSliderGrp -l "Pos"
                                          -p $rampFormName
                                          -ann "Selected Position"
                                          -h 30 -w 102 -cw4 40 60 1 1 $spName`;
    string $scc;
    if ( $isColor )
    {
      $scc  = `attrColorSliderGrp -l "Color"
                                  -p $rampFormName
                                  -ann "Selected Color" -sb false
                                  -h 26 -w 102 -cw4 40 60 1 1 $scName`;
    } 
    else 
    {
      $scc  = `attrFieldSliderGrp -l "Value"
                                    -p $rampFormName
                                    -ann "Selected Value"
                                    -h 30 -w 102 -cw4 40 60 1 1 $scName`;
    }
    string $interp = `attrEnumOptionMenuGrp -l "Interp"
                                            -p $rampFormName
                                            -ann "Interpolation method"
                                            -w 102
                                            -cw2 40 62 $siName`;
    string $lmax;
    if ( $adaptiveScaling ) 
      $lmax = `text -p $rampFormName -label "1.0" ($rampName+"LX")`;
    
    string  $editBttnName;
    if ( $editButton )
    {
      $editBttnName     = ($rampName + "BTTN");
      button -l ">" -width 23 -c ("editRampAttribute "+$plug) $editBttnName;
    }
       
    string  $rampFrameName  = ($rampName + "FRAME");   
    frameLayout -p $rampFormName -bs "etchedIn" -lv 0 -cll 0 $rampFrameName;
    string  $widgetName   = `gradientControl  -p $rampFrameName
                                              -at $plug
                                              -snc $staticEntries
                                              -sp $staticPositions
                                              -ann $description
                                              $rampName`;
    if ( $adaptiveScaling ) 
      gradientControl -e -as $adaptiveScaling -ror $adaptiveScaling -ulc $lmax $widgetName;

    setParent ..;
    formLayout  -edit
            -attachForm   $spc "left"  0
            -attachControl  $spc "right" 2 $rampFrameName
            -attachForm   $spc "top" 0
            -attachNone   $spc "bottom"
    
            -attachForm   $scc "left" 0
            -attachControl  $scc "right" 2 $rampFrameName
            -attachControl  $scc "top" 0 $spc
            -attachNone   $scc "bottom"
    
            -attachForm   $interp "left" 0
            -attachNone   $interp "right"
            -attachControl  $interp "top" 0 $scc
            -attachNone   $interp "bottom"
    
            -attachForm   $rampFrameName "left" 104
            -attachForm   $rampFrameName "right" 23
            -attachForm   $rampFrameName "top" 0
            -attachNone   $rampFrameName "bottom"
            
            $rampFormName;

    if ( $adaptiveScaling ) 
    {
      formLayout  -edit
          -attachNone   $lmax "left"
          -attachControl  $lmax "right" 2 $rampFrameName
          -attachControl  $lmax "top" 0 $interp
          -attachNone   $lmax "bottom"
          $rampFormName;
    }
    if ( $editButton ) 
    { 
      formLayout  -edit   
          -attachControl  $editBttnName "left" 0 $rampFrameName
          -attachForm   $editBttnName "right" 0 
          -attachForm   $editBttnName "top" 0       
          -attachForm   $editBttnName "bottom" 0       
              $rampFormName;
  }
     
  setParent ..;

  // input
  if ( objExists ($plug +"Input") )
  {
    string $inLabel;
    string $labelAttr = interToUI($attr);
    if ( size( $labelAttr ) < 9 ) 
      $inLabel =  ($labelAttr + " Input");
    else 
      $inLabel = "Input";
    attrEnumOptionMenuGrp -l $inLabel
                -p $ramColName
                -ann "input variable for function"
                -cw2 124 155
                -at ($plug + "Input")
                ($rampName + "Input");
  }
  // inputBias
  if (  objExists ($plug +"InputBias") )
  {
    attrFieldSliderGrp  -l "Input Bias"
              -cw4 123 81 130 25
              -p $ramColName
                  -at ($plug +"InputBias")
                  ($rampName + "InputBias");
  }

  // inputScale
  if (  objExists ($plug +"InputScale") )
  {
    attrFieldSliderGrp  -l "Input Scale"
              -cw4 123 81 130 25
              -p $ramColName
              -at ($plug +"InputScale")
              ($rampName + "InputScale");
  }
  // tell the port about the controls
  gradientControl -e -scc $scc $widgetName;
  gradientControl -e -spc $spc $widgetName;
  gradientControl -e -sic $interp $widgetName;

  // add command to unify interpolation (when interpAttr is not a multi)
  if ( $uniqueInterp ) 
  {
    string $optionMenuCtl = ($interp+"|optionMenu");
    if ( `optionMenu -q -ex $optionMenuCtl` ) 
      optionMenu -e -cc ("lifGradient_unifyInterpolation "+$siName+" "+$attr) $optionMenuCtl;
  }
  
  setParent $gLiquid_currentAEParent;
  
  return $rampName;
}

/********************************************************************
  Float or Color spline gradient
********************************************************************/

// Type currently always "gradient" but can be used to create more specific ramp/gradient controls
global proc string liquidAE_LifGradient( string $type, string $label, string $description, int $state,
                      string $gradientParam[], string $gradientParamType[], int $gradientParamSize[] )
{
  global string $gLiquid_currentAEParent;
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;
  
  ltrace ("[liquidAE_LifGradient] on "  +$gLiquid_currentAENode+", UI type "+$type + ", label "+$label                  
                    +" for "+stringArrayToString($gradientParam, " ")
                    +", state "+$state+", desc "+$description);
                                        
  // Save parent for restoration at proc end
  string $saveParent = $gLiquid_currentAEParent;
  setParent $gLiquid_currentAEParent;
  setUITemplate -pst attributeEditorTemplate;
  
  // find which attributes are going to be connected to the widget
  string  $valueAttr      = $gradientParam[0];
  string  $positionAttr   = $gradientParam[1];
  string  $interpAttr     = $gradientParam[2];
  string  $valueType      = $gradientParamType[0];      // float or color/vector/point
  string  $positionType   = $gradientParamType[1];      // should be float
  string  $interpType     = $gradientParamType[2];      // should be float    
  int   $valueSize      = $gradientParamSize[0];
  int   $positionSize   = $gradientParamSize[1];
  int   $interpSize     = $gradientParamSize[2];
  // flags for ramp creation depend on parameter being arrays or not
  // and array size / resizable nature
  int   $staticEntries    = ($valueSize > 0) ? 1 : 0;     // fixed size values array
  int   $staticPositions  = ($positionAttr == "") ? 1 : 0;  // no position attribute
  int   $uniqueInterp   = ($interpSize == -1) ? 1 : 0;    // if interp attribute is not an array
  int   $isColor      = ( $valueType != "float" );    // color or float ramp?
  // TODO : pass these as subtype?  
  int   $adaptiveScaling  = ( $isColor ) ? 0 : 1;
  int   $editButton     = 1;
      
  // Create and connect the compound attribute required by this widget type
  int $isColor      = ( $valueType != "float" );  
  string $compoundAttr  = lifGradientAttr_create( $gLiquid_currentAENode, $valueAttr, $positionAttr, $interpAttr, $isColor );
    
  string $compoundPlug  = ($gLiquid_currentAENode+"."+$compoundAttr);
  string $ctlName     = controlName( ($compoundAttr + "Ramp") );

  if ( !`gradientControl -q -ex $ctlName` ) 
  {
    // Init the compound to reflect $valueAttr existing indices
    lifGradientAttr_init( $gLiquid_currentAENode, $compoundAttr, $valueAttr, $positionAttr, $interpAttr, $isColor );
    // create the control widget
    string $rampFrame = lifGradient_create( $compoundAttr, $label, $description, $state,
                            $staticEntries, $staticPositions, $uniqueInterp,
                            $adaptiveScaling, $editButton );
  } 
  else 
  {
    // reconnect the control widget to the compound
    lifGradient_connect( $ctlName, $compoundAttr, $editButton );
  }
  // Connect the existing compound indices to the valueAttr, positionAttr and interpAttr
  lifGradientAttr_connect( $gLiquid_currentAENode, $compoundAttr, $valueAttr, $positionAttr, $interpAttr, $isColor );
    
  setUITemplate -ppt;
  setParent $saveParent;
  
  return $ctlName;
}



/********************************************************************
  Overrides
********************************************************************/

/**
 *  this proc will update the menuItem's label and command
 *  depending on the override state of the attribute.
 */
global proc liquidAE_LifStringOverrideEnabler( string $nodeDotAttr, string $ctl )
{
  int    $enable        = (`editRenderLayerGlobals -q -crl` == "defaultRenderLayer")? 0 : 1;
  string $nodeOverrides = (" "+stringArrayToString( editRenderLayerAdjustment( "-q" ,$nodeDotAttr), " ")+" ");
  string $remove        = (gmatch( $nodeOverrides, ("* "+$nodeDotAttr+" *"))) ? "-remove":"";
  string $label         = ($remove == "")? "Create Layer Override":"Remove Layer Override";
  int    $state         = ($remove == "")? 1:0;
  string $ctlShort      = match("[A-Za-z0-9_]+$", $ctl);

  ltrace (" >> checking "+$nodeDotAttr+" ( "+$ctlShort+" ) :: isRenderLayer : "+$enable+"  overriden : "+(($remove == "")? "no":"yes"));

  if ( `menuItem -q -ex ($ctlShort+"PopupMenuOVR")` ) 
  {
    menuItem -e -l $label
                -c (  "editRenderLayerAdjustment "+$remove+" "+$nodeDotAttr+";"+
                      "liquidAE_LifStringOverrideDisplay "+$state+" "+$ctlShort+";")
                -en $enable
                ($ctlShort+"PopupMenuOVR");
  } 
  else 
    warning ("[liquidAE_LifStringOverrideEnabler] cannot find "+$ctlShort+"PopupMenuOVR");
}


/**
 *  this proc will create a popupmenu if none can be found.
 *  it will then create/append a menu item to manage the overrides.
 *  the popupmenu has a postcommand to refresh the state/cmd of the menu item.
 */
global proc liquidAE_LifStringOverride( string $attr, string $ctl )
{
  string $parentMenu;

  if ( !`menuItem -q -ex ($ctl+"PopupMenuOVR")` ) 
  {
    // get the popup menu
    string $menus[] = `control -q -pma $ctl`;
    if ( size( $menus ) ) 
    {
      for ( $m in $menus ) 
      {
        if ( `popupMenu -q -b $m` == 3 ) $parentMenu = $m;
      }
    } 
    else 
    {
      $parentMenu = `popupMenu -parent $ctl -button 3 -postMenuCommand ("liquidAE_LifStringOverrideEnabler ($gLiquid_currentAENode+\"."+$attr+"\") "+$ctl) ($ctl+"PopupMenu")`;
    }
    string $t = `menuItem -parent $parentMenu ($ctl+"PopupMenuOVR")`;
  }
}

global proc liquidAE_LifStringOverrideDisplay( int $override, string $ctl )
{
  // remember the original parent
  if ( !objExists( $ctl ) ) return ;

  string $originalParent = `setParent -q`;

  // compute the font and the full path to the control
  string $font = ( $override )? "boldLabelFont":"plainLabelFont";
  string $ctlLabel = ( `setParent $ctl` + "|label" );

  // do it.
  if ( `text -q -ex $ctlLabel` ) 
    text -e -fn $font $ctlLabel;

  // reset the parent
  setParent $originalParent;
}

global proc liquidAE_LifStringOverrideDisplayAll()
{
  // global maintained by maya containing the name
  // of the main attribute editor window.
  global string $gAttributeEditorWindowName;

  // liquid globals containing the current node and shader in the AE
  global string $gLiquid_currentAENode;
  global string $gLiquid_currentAEShader;

  if ( !objExists( $gLiquid_currentAENode ) ) return;

  // is the attribute editor visible ?
  if ( (  `window -exists $gAttributeEditorWindowName`
      &&  `window -q -vis $gAttributeEditorWindowName`)
      || (`isAttributeEditorVisible`))
  {
    // are we dealing with a liquid node ?
    string $nodetype = nodeType($gLiquid_currentAENode);
    if ( gmatch( $nodetype, "*liquid*") ) 
    {
      // remember the original parent
      string $originalParent = `setParent -q`;
  
      // default layer or render layer ?
      int $isRenderLayer = (`editRenderLayerGlobals -q -crl` == "defaultRenderLayer")? 0 : 1;
  
      // get the list of overriden params
      string $nodeOverrides = (" "+stringArrayToString( editRenderLayerAdjustment( "-q" ,$gLiquid_currentAENode), " ")+" " );
  
      // get the list of string attributes on the node
      string $userAttr[] = `listAttr -ud $gLiquid_currentAENode`;
  
      string $versionString = `about -v`;
      float $version = catchQuiet( match("[0-9]+\\.[0-9]+", $versionString ) );
      string $a;
    
      for ( $a in $userAttr ) 
      {
        if ( ($a != "rmanLifCmds") && ($a != "rmanLifCtrls") ) 
        {
          if ( !objExists( ($gLiquid_currentAENode+"."+$a) ) ) continue;
          // early exit if we have a message or string attr.
          if ( $version >= 8.0 && `attributeQuery -node $gLiquid_currentAENode -message $a` ) continue;
          string $aType = `getAttr -type ($gLiquid_currentAENode+"."+$a)`;
          if ( $aType != "string" ) continue;
          ltrace ("[liquidAE_LifStringOverrideDisplayAll] for attribute "+$a+"\n");
          string $ctlName = ( $gLiquid_currentAEShader + "_" + match("[A-Za-z0-9_]+$", $a) + "_0_LIF" );
          int $overrideState = ( $isRenderLayer && gmatch( $nodeOverrides, ("* "+$gLiquid_currentAENode+"."+$a+" *")) )? 1:0;
          liquidAE_LifStringOverrideDisplay( $overrideState, $ctlName );
        }
      }
      setParent $originalParent;
    }
  }
}
